/* tslint:disable */
/* eslint-disable */
/**
 * grocy REST API
 * Authentication is done via API keys (header *GROCY-API-KEY* or same named query parameter), which you can manage [here](https://demo.grocy.info/manageapikeys).<br>Additionally requests from within the frontend are also valid (via session cookie).
 *
 * The version of the OpenAPI document: 3.1.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {number}
     * @memberof ApiKey
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'api_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'expires'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'last_used'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface Battery
 */
export interface Battery {
    /**
     * 
     * @type {number}
     * @memberof Battery
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Battery
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Battery
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Battery
     */
    'used_in'?: string;
    /**
     * 
     * @type {number}
     * @memberof Battery
     */
    'charge_interval_days'?: number;
    /**
     * 
     * @type {string}
     * @memberof Battery
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof Battery
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface BatteryChargeCycleEntry
 */
export interface BatteryChargeCycleEntry {
    /**
     * 
     * @type {number}
     * @memberof BatteryChargeCycleEntry
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof BatteryChargeCycleEntry
     */
    'battery_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatteryChargeCycleEntry
     */
    'tracked_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof BatteryChargeCycleEntry
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface BatteryDetailsResponse
 */
export interface BatteryDetailsResponse {
    /**
     * 
     * @type {Battery}
     * @memberof BatteryDetailsResponse
     */
    'chore'?: Battery;
    /**
     * When this battery was last charged
     * @type {string}
     * @memberof BatteryDetailsResponse
     */
    'last_charged'?: string;
    /**
     * How often this battery was charged so far
     * @type {number}
     * @memberof BatteryDetailsResponse
     */
    'charge_cycles_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof BatteryDetailsResponse
     */
    'next_estimated_charge_time'?: string;
}
/**
 * 
 * @export
 * @interface Chore
 */
export interface Chore {
    /**
     * 
     * @type {number}
     * @memberof Chore
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'period_type'?: ChorePeriodTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'period_config'?: string;
    /**
     * 
     * @type {number}
     * @memberof Chore
     */
    'period_days'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Chore
     */
    'track_date_only'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Chore
     */
    'rollover'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'assignment_type'?: ChoreAssignmentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'assignment_config'?: string;
    /**
     * 
     * @type {number}
     * @memberof Chore
     */
    'next_execution_assigned_to_user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Chore
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof Chore
     */
    'userfields'?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum ChorePeriodTypeEnum {
    Manually = 'manually',
    DynamicRegular = 'dynamic-regular',
    Daily = 'daily',
    Weekly = 'weekly',
    Monthly = 'monthly'
}
/**
    * @export
    * @enum {string}
    */
export enum ChoreAssignmentTypeEnum {
    NoAssignment = 'no-assignment',
    WhoLeastDidFirst = 'who-least-did-first',
    Random = 'random',
    InAlphabeticalOrder = 'in-alphabetical-order'
}

/**
 * 
 * @export
 * @interface ChoreDetailsResponse
 */
export interface ChoreDetailsResponse {
    /**
     * 
     * @type {Chore}
     * @memberof ChoreDetailsResponse
     */
    'chore'?: Chore;
    /**
     * When this chore was last tracked
     * @type {string}
     * @memberof ChoreDetailsResponse
     */
    'last_tracked'?: string;
    /**
     * How often this chore was tracked so far
     * @type {number}
     * @memberof ChoreDetailsResponse
     */
    'track_count'?: number;
    /**
     * 
     * @type {UserDto}
     * @memberof ChoreDetailsResponse
     */
    'last_done_by'?: UserDto;
    /**
     * 
     * @type {string}
     * @memberof ChoreDetailsResponse
     */
    'next_estimated_execution_time'?: string;
    /**
     * 
     * @type {UserDto}
     * @memberof ChoreDetailsResponse
     */
    'next_execution_assigned_user'?: UserDto;
}
/**
 * 
 * @export
 * @interface ChoreLogEntry
 */
export interface ChoreLogEntry {
    /**
     * 
     * @type {number}
     * @memberof ChoreLogEntry
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChoreLogEntry
     */
    'chore_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChoreLogEntry
     */
    'tracked_time'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChoreLogEntry
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface CurrentBatteryResponse
 */
export interface CurrentBatteryResponse {
    /**
     * 
     * @type {number}
     * @memberof CurrentBatteryResponse
     */
    'battery_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentBatteryResponse
     */
    'last_tracked_time'?: string;
    /**
     * The next estimated charge time of this battery, 2999-12-31 23:59:59 when the given battery has no charge_interval_days defined
     * @type {string}
     * @memberof CurrentBatteryResponse
     */
    'next_estimated_charge_time'?: string;
}
/**
 * 
 * @export
 * @interface CurrentChoreResponse
 */
export interface CurrentChoreResponse {
    /**
     * 
     * @type {number}
     * @memberof CurrentChoreResponse
     */
    'chore_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentChoreResponse
     */
    'chore_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentChoreResponse
     */
    'last_tracked_time'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CurrentChoreResponse
     */
    'track_date_only'?: boolean;
    /**
     * The next estimated execution time of this chore, 2999-12-31 23:59:59 when the given chore has a period_type of manually
     * @type {string}
     * @memberof CurrentChoreResponse
     */
    'next_estimated_execution_time'?: string;
    /**
     * 
     * @type {number}
     * @memberof CurrentChoreResponse
     */
    'next_execution_assigned_to_user_id'?: number;
    /**
     * 
     * @type {UserDto}
     * @memberof CurrentChoreResponse
     */
    'next_execution_assigned_user'?: UserDto;
}
/**
 * 
 * @export
 * @interface CurrentStockResponse
 */
export interface CurrentStockResponse {
    /**
     * 
     * @type {number}
     * @memberof CurrentStockResponse
     */
    'product_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrentStockResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrentStockResponse
     */
    'amount_aggregated'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrentStockResponse
     */
    'amount_opened'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrentStockResponse
     */
    'amount_opened_aggregated'?: number;
    /**
     * The next due date for this product
     * @type {string}
     * @memberof CurrentStockResponse
     */
    'best_before_date'?: string;
    /**
     * Indicates wheter this product has sub-products or not / if the fields `amount_aggregated` and `amount_opened_aggregated` are filled
     * @type {boolean}
     * @memberof CurrentStockResponse
     */
    'is_aggregated_amount'?: boolean;
    /**
     * 
     * @type {Product}
     * @memberof CurrentStockResponse
     */
    'product'?: Product;
}
/**
 * 
 * @export
 * @interface CurrentTaskResponse
 */
export interface CurrentTaskResponse {
    /**
     * 
     * @type {number}
     * @memberof CurrentTaskResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentTaskResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTaskResponse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrentTaskResponse
     */
    'due_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTaskResponse
     */
    'done'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentTaskResponse
     */
    'done_timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof CurrentTaskResponse
     */
    'category_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CurrentTaskResponse
     */
    'assigned_to_user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrentTaskResponse
     */
    'row_created_timestamp'?: string;
    /**
     * 
     * @type {UserDto}
     * @memberof CurrentTaskResponse
     */
    'assigned_to_user'?: UserDto;
    /**
     * 
     * @type {TaskCategory}
     * @memberof CurrentTaskResponse
     */
    'category'?: TaskCategory;
}
/**
 * 
 * @export
 * @interface CurrentVolatilStockResponse
 */
export interface CurrentVolatilStockResponse {
    /**
     * 
     * @type {Array<CurrentStockResponse>}
     * @memberof CurrentVolatilStockResponse
     */
    'due_products'?: Array<CurrentStockResponse>;
    /**
     * 
     * @type {Array<CurrentStockResponse>}
     * @memberof CurrentVolatilStockResponse
     */
    'overdue_products'?: Array<CurrentStockResponse>;
    /**
     * 
     * @type {Array<CurrentStockResponse>}
     * @memberof CurrentVolatilStockResponse
     */
    'expired_products'?: Array<CurrentStockResponse>;
    /**
     * 
     * @type {Array<object>}
     * @memberof CurrentVolatilStockResponse
     */
    'missing_products'?: Array<object>;
}
/**
 * 
 * @export
 * @interface DbChangedTimeResponse
 */
export interface DbChangedTimeResponse {
    /**
     * 
     * @type {string}
     * @memberof DbChangedTimeResponse
     */
    'changed_time'?: string;
}
/**
 * 
 * @export
 * @interface Error400
 */
export interface Error400 {
    /**
     * 
     * @type {string}
     * @memberof Error400
     */
    'error_message'?: string;
}
/**
 * 
 * @export
 * @interface Error500
 */
export interface Error500 {
    /**
     * 
     * @type {string}
     * @memberof Error500
     */
    'error_message'?: string;
    /**
     * 
     * @type {Error500ErrorDetails}
     * @memberof Error500
     */
    'error_details'?: Error500ErrorDetails;
}
/**
 * 
 * @export
 * @interface Error500ErrorDetails
 */
export interface Error500ErrorDetails {
    /**
     * 
     * @type {string}
     * @memberof Error500ErrorDetails
     */
    'stack_trace'?: string;
    /**
     * 
     * @type {string}
     * @memberof Error500ErrorDetails
     */
    'file'?: string;
    /**
     * 
     * @type {number}
     * @memberof Error500ErrorDetails
     */
    'line'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntity {
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    ApiKeys = 'api_keys',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    StockLog = 'stock_log',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    ChoresLog = 'chores_log',
    MealPlanSections = 'meal_plan_sections'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityEditRequiresAdmin {
    ApiKeys = 'api_keys'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityIncludingUserEntities {
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    ApiKeys = 'api_keys',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    StockLog = 'stock_log',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    ChoresLog = 'chores_log',
    MealPlanSections = 'meal_plan_sections',
    ApiKeys = 'api_keys',
    Batteries = 'batteries',
    Chores = 'chores',
    ChoresLog = 'chores_log',
    Equipment = 'equipment',
    Locations = 'locations',
    MealPlan = 'meal_plan',
    MealPlanSections = 'meal_plan_sections',
    ProductBarcodes = 'product_barcodes',
    ProductGroups = 'product_groups',
    Products = 'products',
    QuantityUnitConversions = 'quantity_unit_conversions',
    QuantityUnits = 'quantity_units',
    Recipes = 'recipes',
    RecipesNestings = 'recipes_nestings',
    RecipesPos = 'recipes_pos',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    StockLog = 'stock_log',
    TaskCategories = 'task_categories',
    Tasks = 'tasks',
    Userentities = 'userentities',
    UserentityExampleuserentity = 'userentity-exampleuserentity',
    UserentityNgluserentity = 'userentity-ngluserentity',
    Userfields = 'userfields',
    Userobjects = 'userobjects',
    Users = 'users'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityIncludingUserEntitiesNotIncludingNotEditable {
    Empty = '',
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    MealPlanSections = 'meal_plan_sections',
    Batteries = 'batteries',
    Chores = 'chores',
    Equipment = 'equipment',
    Locations = 'locations',
    MealPlan = 'meal_plan',
    MealPlanSections = 'meal_plan_sections',
    ProductBarcodes = 'product_barcodes',
    ProductGroups = 'product_groups',
    Products = 'products',
    QuantityUnitConversions = 'quantity_unit_conversions',
    QuantityUnits = 'quantity_units',
    Recipes = 'recipes',
    RecipesNestings = 'recipes_nestings',
    RecipesPos = 'recipes_pos',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    TaskCategories = 'task_categories',
    Tasks = 'tasks',
    Userentities = 'userentities',
    UserentityExampleuserentity = 'userentity-exampleuserentity',
    UserentityNgluserentity = 'userentity-ngluserentity',
    Userfields = 'userfields',
    Userobjects = 'userobjects',
    Users = 'users'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNoDelete {
    StockLog = 'stock_log',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    ChoresLog = 'chores_log'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNoEdit {
    StockLog = 'stock_log',
    ApiKeys = 'api_keys',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    ChoresLog = 'chores_log'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNoListing {
    ApiKeys = 'api_keys'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNotIncludingNotDeletable {
    Empty = '',
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    ApiKeys = 'api_keys',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    MealPlanSections = 'meal_plan_sections'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNotIncludingNotEditable {
    Empty = '',
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    MealPlanSections = 'meal_plan_sections'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum ExposedEntityNotIncludingNotListable {
    Empty = '',
    Products = 'products',
    Chores = 'chores',
    ProductBarcodes = 'product_barcodes',
    Batteries = 'batteries',
    Locations = 'locations',
    QuantityUnits = 'quantity_units',
    QuantityUnitConversions = 'quantity_unit_conversions',
    ShoppingList = 'shopping_list',
    ShoppingLists = 'shopping_lists',
    ShoppingLocations = 'shopping_locations',
    Recipes = 'recipes',
    RecipesPos = 'recipes_pos',
    RecipesNestings = 'recipes_nestings',
    Tasks = 'tasks',
    TaskCategories = 'task_categories',
    ProductGroups = 'product_groups',
    Equipment = 'equipment',
    Userfields = 'userfields',
    Userentities = 'userentities',
    Userobjects = 'userobjects',
    MealPlan = 'meal_plan',
    StockLog = 'stock_log',
    Stock = 'stock',
    StockCurrentLocations = 'stock_current_locations',
    ChoresLog = 'chores_log',
    MealPlanSections = 'meal_plan_sections'
}

/**
 * 
 * @export
 * @interface ExternalBarcodeLookupResponse
 */
export interface ExternalBarcodeLookupResponse {
    /**
     * 
     * @type {string}
     * @memberof ExternalBarcodeLookupResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ExternalBarcodeLookupResponse
     */
    'location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExternalBarcodeLookupResponse
     */
    'qu_id_purchase'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExternalBarcodeLookupResponse
     */
    'qu_id_stock'?: number;
    /**
     * 
     * @type {number}
     * @memberof ExternalBarcodeLookupResponse
     */
    'qu_factor_purchase_to_stock'?: number;
    /**
     * Can contain multiple barcodes separated by comma
     * @type {string}
     * @memberof ExternalBarcodeLookupResponse
     */
    'barcode'?: string;
    /**
     * The id of the added product, only included when the producted was added to the database
     * @type {number}
     * @memberof ExternalBarcodeLookupResponse
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum FileGroups {
    Equipmentmanuals = 'equipmentmanuals',
    Recipepictures = 'recipepictures',
    Productpictures = 'productpictures',
    Userfiles = 'userfiles',
    Userpictures = 'userpictures'
}

/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * A list of permission ids
     * @type {Array<number>}
     * @memberof InlineObject
     */
    'permissions'?: Array<number>;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * A permission ids
     * @type {number}
     * @memberof InlineObject1
     */
    'permissions_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
    /**
     * The amount to transfer - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject10
     */
    'amount'?: number;
    /**
     * A valid location id, the location from where the product should be transfered
     * @type {number}
     * @memberof InlineObject10
     */
    'location_id_from'?: number;
    /**
     * A valid location id, the location to where the product should be transfered
     * @type {number}
     * @memberof InlineObject10
     */
    'location_id_to'?: number;
    /**
     * A specific stock entry id to transfer, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject10
     */
    'stock_entry_id'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
    /**
     * The new current amount for the given product - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject11
     */
    'new_amount'?: number;
    /**
     * The due date which applies to added products
     * @type {string}
     * @memberof InlineObject11
     */
    'best_before_date'?: string;
    /**
     * If omitted, the default location of the product is used (only applies to added products)
     * @type {number}
     * @memberof InlineObject11
     */
    'location_id'?: number;
    /**
     * If omitted, the last price of the product is used (only applies to added products)
     * @type {number}
     * @memberof InlineObject11
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
    /**
     * The amount to mark as opened
     * @type {number}
     * @memberof InlineObject12
     */
    'amount'?: number;
    /**
     * A specific stock entry id to open, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject12
     */
    'stock_entry_id'?: string;
    /**
     * `True` when any in-stock sub product should be used when the given product is a parent product and currently not in-stock
     * @type {boolean}
     * @memberof InlineObject12
     */
    'allow_subproduct_substitution'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
    /**
     * The shopping list to use, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject13
     */
    'list_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
    /**
     * The shopping list to use, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject14
     */
    'list_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
    /**
     * The shopping list to use, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject15
     */
    'list_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
    /**
     * The shopping list id to clear, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject16
     */
    'list_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
    /**
     * A valid product id of the item on the shopping list
     * @type {number}
     * @memberof InlineObject17
     */
    'product_id'?: number;
    /**
     * A valid shopping list id, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject17
     */
    'list_id'?: number;
    /**
     * The amount of product units to add, when omitted, the default amount of 1 is used
     * @type {number}
     * @memberof InlineObject17
     */
    'product_amount'?: number;
    /**
     * The note of the shopping list item
     * @type {string}
     * @memberof InlineObject17
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
    /**
     * A valid product id of the item on the shopping list
     * @type {number}
     * @memberof InlineObject18
     */
    'product_id'?: number;
    /**
     * A valid shopping list id, when omitted, the default shopping list (with id 1) is used
     * @type {number}
     * @memberof InlineObject18
     */
    'list_id'?: number;
    /**
     * The amount of product units to remove, when omitted, the default amount of 1 is used
     * @type {number}
     * @memberof InlineObject18
     */
    'product_amount'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
    /**
     * An optional array of product ids to exclude them from being put on the shopping list
     * @type {Array<number>}
     * @memberof InlineObject19
     */
    'excludedProductIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject2
     */
    'amount'?: number;
    /**
     * The due date of the product to add, when omitted, the current date is used
     * @type {string}
     * @memberof InlineObject2
     */
    'best_before_date'?: string;
    /**
     * The price per stock quantity unit in configured currency
     * @type {number}
     * @memberof InlineObject2
     */
    'price'?: number;
    /**
     * If the stock entry was already opened or not
     * @type {boolean}
     * @memberof InlineObject2
     */
    'open'?: boolean;
    /**
     * If omitted, the default location of the product is used
     * @type {number}
     * @memberof InlineObject2
     */
    'location_id'?: number;
    /**
     * If omitted, no store will be affected
     * @type {number}
     * @memberof InlineObject2
     */
    'shopping_location_id'?: number;
    /**
     * The date when this stock entry was purchased
     * @type {string}
     * @memberof InlineObject2
     */
    'purchased_date'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
    /**
     * The time of when the chore was executed, when omitted, the current time is used
     * @type {string}
     * @memberof InlineObject20
     */
    'tracked_time'?: string;
    /**
     * A valid user id of who executed this chore, when omitted, the currently authenticated user will be used
     * @type {number}
     * @memberof InlineObject20
     */
    'done_by'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
    /**
     * The chore id of the chore which next user assignment should be (re)calculated, when omitted, the next user assignments of all chores will (re)caluclated
     * @type {number}
     * @memberof InlineObject21
     */
    'chore_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
    /**
     * The time of when the battery was charged, when omitted, the current time is used
     * @type {string}
     * @memberof InlineObject22
     */
    'tracked_time'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
    /**
     * The time of when the task was completed, when omitted, the current time is used
     * @type {string}
     * @memberof InlineObject23
     */
    'done_time'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject3
     */
    'amount'?: number;
    /**
     * The due date of the product to add, when omitted, the current date is used
     * @type {string}
     * @memberof InlineObject3
     */
    'best_before_date'?: string;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof InlineObject3
     */
    'transaction_type'?: StockTransactionType;
    /**
     * The price per stock quantity unit in configured currency
     * @type {number}
     * @memberof InlineObject3
     */
    'price'?: number;
    /**
     * If omitted, the default location of the product is used
     * @type {number}
     * @memberof InlineObject3
     */
    'location_id'?: number;
    /**
     * If omitted, no store will be affected
     * @type {number}
     * @memberof InlineObject3
     */
    'shopping_location_id'?: number;
    /**
     * `1` = No label, `2` = Single label, `3` = Label per unit
     * @type {number}
     * @memberof InlineObject3
     */
    'stock_label_type'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
    /**
     * The amount to remove - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject4
     */
    'amount'?: number;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof InlineObject4
     */
    'transaction_type'?: StockTransactionType;
    /**
     * True when the given product was spoiled, defaults to false
     * @type {boolean}
     * @memberof InlineObject4
     */
    'spoiled'?: boolean;
    /**
     * A specific stock entry id to consume, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject4
     */
    'stock_entry_id'?: string;
    /**
     * A valid recipe id for which this product was used (for statistical purposes only)
     * @type {number}
     * @memberof InlineObject4
     */
    'recipe_id'?: number;
    /**
     * A valid location id (if supplied, only stock at the given location is considered, if ommitted, stock of any location is considered)
     * @type {number}
     * @memberof InlineObject4
     */
    'location_id'?: number;
    /**
     * For tare weight handling enabled products, `true` when the given is the absolute amount to be consumed, not the amount including the container weight
     * @type {boolean}
     * @memberof InlineObject4
     */
    'exact_amount'?: boolean;
    /**
     * `True` when any in-stock sub product should be used when the given product is a parent product and currently not in-stock
     * @type {boolean}
     * @memberof InlineObject4
     */
    'allow_subproduct_substitution'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
    /**
     * The amount to transfer - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject5
     */
    'amount'?: number;
    /**
     * A valid location id, the location from where the product should be transfered
     * @type {number}
     * @memberof InlineObject5
     */
    'location_id_from'?: number;
    /**
     * A valid location id, the location to where the product should be transfered
     * @type {number}
     * @memberof InlineObject5
     */
    'location_id_to'?: number;
    /**
     * A specific stock entry id to transfer, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject5
     */
    'stock_entry_id'?: string;
}
/**
 * 
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
    /**
     * The new current amount for the given product - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject6
     */
    'new_amount'?: number;
    /**
     * The due date which applies to added products
     * @type {string}
     * @memberof InlineObject6
     */
    'best_before_date'?: string;
    /**
     * If omitted, no store will be affected
     * @type {number}
     * @memberof InlineObject6
     */
    'shopping_location_id'?: number;
    /**
     * If omitted, the default location of the product is used (only applies to added products)
     * @type {number}
     * @memberof InlineObject6
     */
    'location_id'?: number;
    /**
     * If omitted, the last price of the product is used (only applies to added products)
     * @type {number}
     * @memberof InlineObject6
     */
    'price'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
    /**
     * The amount to mark as opened
     * @type {number}
     * @memberof InlineObject7
     */
    'amount'?: number;
    /**
     * A specific stock entry id to open, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject7
     */
    'stock_entry_id'?: string;
    /**
     * `True` when any in-stock sub product should be used when the given product is a parent product and currently not in-stock
     * @type {boolean}
     * @memberof InlineObject7
     */
    'allow_subproduct_substitution'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
    /**
     * The amount to add - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject8
     */
    'amount'?: number;
    /**
     * The due date of the product to add, when omitted, the current date is used
     * @type {string}
     * @memberof InlineObject8
     */
    'best_before_date'?: string;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof InlineObject8
     */
    'transaction_type'?: StockTransactionType;
    /**
     * The price per stock quantity unit in configured currency
     * @type {number}
     * @memberof InlineObject8
     */
    'price'?: number;
    /**
     * If omitted, the default location of the product is used
     * @type {number}
     * @memberof InlineObject8
     */
    'location_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
    /**
     * The amount to remove - please note that when tare weight handling for the product is enabled, this needs to be the amount including the container weight (gross), the amount to be posted will be automatically calculated based on what is in stock and the defined tare weight
     * @type {number}
     * @memberof InlineObject9
     */
    'amount'?: number;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof InlineObject9
     */
    'transaction_type'?: StockTransactionType;
    /**
     * True when the given product was spoiled, defaults to false
     * @type {boolean}
     * @memberof InlineObject9
     */
    'spoiled'?: boolean;
    /**
     * A specific stock entry id to consume, if used, the amount has to be 1
     * @type {string}
     * @memberof InlineObject9
     */
    'stock_entry_id'?: string;
    /**
     * A valid recipe id for which this product was used (for statistical purposes only)
     * @type {number}
     * @memberof InlineObject9
     */
    'recipe_id'?: number;
    /**
     * A valid location id (if supplied, only stock at the given location is considered, if ommitted, stock of any location is considered)
     * @type {number}
     * @memberof InlineObject9
     */
    'location_id'?: number;
    /**
     * For tare weight handling enabled products, `true` when the given is the absolute amount to be consumed, not the amount including the container weight
     * @type {boolean}
     * @memberof InlineObject9
     */
    'exact_amount'?: boolean;
    /**
     * `True` when any in-stock sub product should be used when the given product is a parent product and currently not in-stock
     * @type {boolean}
     * @memberof InlineObject9
     */
    'allow_subproduct_substitution'?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {InlineResponse200GrocyVersion}
     * @memberof InlineResponse200
     */
    'grocy_version'?: InlineResponse200GrocyVersion;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'php_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    'sqlite_version'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The id of the created object
     * @type {number}
     * @memberof InlineResponse2001
     */
    'created_object_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    'permission_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    'user_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * The id of the created recipe
     * @type {number}
     * @memberof InlineResponse2003
     */
    'created_object_id'?: number;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    'result'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200GrocyVersion
 */
export interface InlineResponse200GrocyVersion {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200GrocyVersion
     */
    'Version'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200GrocyVersion
     */
    'ReleaseDate'?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Location
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof Location
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface MissingLocalizationRequest
 */
export interface MissingLocalizationRequest {
    /**
     * 
     * @type {string}
     * @memberof MissingLocalizationRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'qu_id_purchase'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'qu_id_stock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'enable_tare_weight_handling'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'not_check_stock_fulfillment_for_recipes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'product_group_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'qu_factor_purchase_to_stock'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'tare_weight'?: number;
    /**
     * Can contain multiple barcodes separated by comma
     * @type {string}
     * @memberof Product
     */
    'barcode'?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'min_stock_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'default_best_before_days'?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'default_best_before_days_after_open'?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'picture_file_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'row_created_timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    'shopping_location_id'?: number;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof Product
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface ProductBarcode
 */
export interface ProductBarcode {
    /**
     * 
     * @type {number}
     * @memberof ProductBarcode
     */
    'product_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductBarcode
     */
    'barcode'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductBarcode
     */
    'qu_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductBarcode
     */
    'shopping_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductBarcode
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductBarcode
     */
    'last_price'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductBarcode
     */
    'note'?: string;
}
/**
 * 
 * @export
 * @interface ProductDetailsResponse
 */
export interface ProductDetailsResponse {
    /**
     * 
     * @type {Product}
     * @memberof ProductDetailsResponse
     */
    'product'?: Product;
    /**
     * 
     * @type {ProductBarcode}
     * @memberof ProductDetailsResponse
     */
    'product_barcodes'?: ProductBarcode;
    /**
     * 
     * @type {QuantityUnit}
     * @memberof ProductDetailsResponse
     */
    'default_quantity_unit_purchase'?: QuantityUnit;
    /**
     * 
     * @type {QuantityUnit}
     * @memberof ProductDetailsResponse
     */
    'quantity_unit_stock'?: QuantityUnit;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailsResponse
     */
    'last_purchased'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailsResponse
     */
    'last_used'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'stock_amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'stock_amount_opened'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetailsResponse
     */
    'next_due_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'last_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'avg_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'oldest_price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'last_shopping_location_id'?: number;
    /**
     * 
     * @type {Location}
     * @memberof ProductDetailsResponse
     */
    'location'?: Location;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'average_shelf_life_days'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetailsResponse
     */
    'spoil_rate_percent'?: number;
    /**
     * True when the product is a parent products of others
     * @type {boolean}
     * @memberof ProductDetailsResponse
     */
    'has_childs'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductPriceHistory
 */
export interface ProductPriceHistory {
    /**
     * 
     * @type {string}
     * @memberof ProductPriceHistory
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductPriceHistory
     */
    'price'?: number;
    /**
     * 
     * @type {ShoppingLocation}
     * @memberof ProductPriceHistory
     */
    'shopping_location'?: ShoppingLocation;
}
/**
 * 
 * @export
 * @interface QuantityUnit
 */
export interface QuantityUnit {
    /**
     * 
     * @type {number}
     * @memberof QuantityUnit
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuantityUnit
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuantityUnit
     */
    'name_plural'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuantityUnit
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuantityUnit
     */
    'row_created_timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuantityUnit
     */
    'plural_forms'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof QuantityUnit
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface RecipeFulfillmentResponse
 */
export interface RecipeFulfillmentResponse {
    /**
     * 
     * @type {number}
     * @memberof RecipeFulfillmentResponse
     */
    'recipe_id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeFulfillmentResponse
     */
    'need_fulfilled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeFulfillmentResponse
     */
    'need_fulfilled_with_shopping_list'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeFulfillmentResponse
     */
    'missing_products_count'?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeFulfillmentResponse
     */
    'costs'?: number;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * 
     * @type {number}
     * @memberof Session
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'session_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'expires'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'last_used'?: string;
    /**
     * 
     * @type {string}
     * @memberof Session
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface ShoppingListItem
 */
export interface ShoppingListItem {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListItem
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListItem
     */
    'shopping_list_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListItem
     */
    'product_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListItem
     */
    'note'?: string;
    /**
     * The manual entered amount
     * @type {number}
     * @memberof ShoppingListItem
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListItem
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof ShoppingListItem
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface ShoppingLocation
 */
export interface ShoppingLocation {
    /**
     * 
     * @type {number}
     * @memberof ShoppingLocation
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingLocation
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingLocation
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingLocation
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof ShoppingLocation
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface StockEntry
 */
export interface StockEntry {
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'product_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'shopping_location_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockEntry
     */
    'best_before_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockEntry
     */
    'purchased_date'?: string;
    /**
     * A unique id which references this stock entry during its lifetime
     * @type {string}
     * @memberof StockEntry
     */
    'stock_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockEntry
     */
    'open'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockEntry
     */
    'opened_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockEntry
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface StockJournal
 */
export interface StockJournal {
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'correlation_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockJournal
     */
    'undone'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'undone_timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockJournal
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockJournal
     */
    'location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'location_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'product_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'qu_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'qu_name_plural'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'user_display_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StockJournal
     */
    'spoiled'?: boolean;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof StockJournal
     */
    'transaction_type'?: StockTransactionType;
    /**
     * 
     * @type {string}
     * @memberof StockJournal
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface StockJournalSummary
 */
export interface StockJournalSummary {
    /**
     * 
     * @type {number}
     * @memberof StockJournalSummary
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockJournalSummary
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockJournalSummary
     */
    'product_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockJournalSummary
     */
    'product_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockJournalSummary
     */
    'qu_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournalSummary
     */
    'qu_name_plural'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockJournalSummary
     */
    'user_display_name'?: string;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof StockJournalSummary
     */
    'transaction_type'?: StockTransactionType;
}
/**
 * 
 * @export
 * @interface StockLocation
 */
export interface StockLocation {
    /**
     * 
     * @type {number}
     * @memberof StockLocation
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockLocation
     */
    'product_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockLocation
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockLocation
     */
    'location_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockLocation
     */
    'location_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof StockLocation
     */
    'location_is_freezer'?: number;
}
/**
 * 
 * @export
 * @interface StockLogEntry
 */
export interface StockLogEntry {
    /**
     * 
     * @type {number}
     * @memberof StockLogEntry
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockLogEntry
     */
    'product_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof StockLogEntry
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'best_before_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'purchased_date'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'used_date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StockLogEntry
     */
    'spoiled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'stock_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'transaction_id'?: string;
    /**
     * 
     * @type {StockTransactionType}
     * @memberof StockLogEntry
     */
    'transaction_type'?: StockTransactionType;
    /**
     * 
     * @type {string}
     * @memberof StockLogEntry
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum StockTransactionType {
    Purchase = 'purchase',
    Consume = 'consume',
    InventoryCorrection = 'inventory-correction',
    ProductOpened = 'product-opened'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum StringEnumTemplate {
    Empty = ''
}

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'due_date'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'done'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'done_timestamp'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'category_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'assigned_to_user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'row_created_timestamp'?: string;
    /**
     * Key/value pairs of userfields
     * @type {object}
     * @memberof Task
     */
    'userfields'?: object;
}
/**
 * 
 * @export
 * @interface TaskCategory
 */
export interface TaskCategory {
    /**
     * 
     * @type {number}
     * @memberof TaskCategory
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskCategory
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCategory
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskCategory
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface TimeResponse
 */
export interface TimeResponse {
    /**
     * 
     * @type {string}
     * @memberof TimeResponse
     */
    'timezone'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeResponse
     */
    'time_local'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeResponse
     */
    'time_local_sqlite3'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeResponse
     */
    'time_utc'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeResponse
     */
    'timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof TimeResponse
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'picture_file_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'row_created_timestamp'?: string;
}
/**
 * A user object without the *password* and with an additional *display_name* property
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'picture_file_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'row_created_timestamp'?: string;
}
/**
 * 
 * @export
 * @interface UserSetting
 */
export interface UserSetting {
    /**
     * 
     * @type {string}
     * @memberof UserSetting
     */
    'value'?: string;
}

/**
 * BatteriesApi - axios parameter creator
 * @export
 */
export const BatteriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Tracks a charge cycle of the given battery
         * @param {number} batteryId A valid battery id
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdChargePost: async (batteryId: number, inlineObject22: InlineObject22, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batteryId' is not null or undefined
            assertParamExists('batteriesBatteryIdChargePost', 'batteryId', batteryId)
            // verify required parameter 'inlineObject22' is not null or undefined
            assertParamExists('batteriesBatteryIdChargePost', 'inlineObject22', inlineObject22)
            const localVarPath = `/batteries/{batteryId}/charge`
                .replace(`{${"batteryId"}}`, encodeURIComponent(String(batteryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject22, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns details of the given battery
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdGet: async (batteryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batteryId' is not null or undefined
            assertParamExists('batteriesBatteryIdGet', 'batteryId', batteryId)
            const localVarPath = `/batteries/{batteryId}`
                .replace(`{${"batteryId"}}`, encodeURIComponent(String(batteryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prints the grocycode label of the given battery on the configured label printer
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdPrintlabelGet: async (batteryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batteryId' is not null or undefined
            assertParamExists('batteriesBatteryIdPrintlabelGet', 'batteryId', batteryId)
            const localVarPath = `/batteries/{batteryId}/printlabel`
                .replace(`{${"batteryId"}}`, encodeURIComponent(String(batteryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undoes a battery charge cycle
         * @param {number} chargeCycleId A valid charge cycle id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesChargeCyclesChargeCycleIdUndoPost: async (chargeCycleId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chargeCycleId' is not null or undefined
            assertParamExists('batteriesChargeCyclesChargeCycleIdUndoPost', 'chargeCycleId', chargeCycleId)
            const localVarPath = `/batteries/charge-cycles/{chargeCycleId}/undo`
                .replace(`{${"chargeCycleId"}}`, encodeURIComponent(String(chargeCycleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all batteries incl. the next estimated charge time per battery
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesGet: async (query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/batteries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BatteriesApi - functional programming interface
 * @export
 */
export const BatteriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BatteriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Tracks a charge cycle of the given battery
         * @param {number} batteryId A valid battery id
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batteriesBatteryIdChargePost(batteryId: number, inlineObject22: InlineObject22, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatteryChargeCycleEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batteriesBatteryIdChargePost(batteryId, inlineObject22, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns details of the given battery
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batteriesBatteryIdGet(batteryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatteryDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batteriesBatteryIdGet(batteryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prints the grocycode label of the given battery on the configured label printer
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batteriesBatteryIdPrintlabelGet(batteryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batteriesBatteryIdPrintlabelGet(batteryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undoes a battery charge cycle
         * @param {number} chargeCycleId A valid charge cycle id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all batteries incl. the next estimated charge time per battery
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batteriesGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentBatteryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batteriesGet(query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BatteriesApi - factory interface
 * @export
 */
export const BatteriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BatteriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Tracks a charge cycle of the given battery
         * @param {number} batteryId A valid battery id
         * @param {InlineObject22} inlineObject22 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdChargePost(batteryId: number, inlineObject22: InlineObject22, options?: any): AxiosPromise<BatteryChargeCycleEntry> {
            return localVarFp.batteriesBatteryIdChargePost(batteryId, inlineObject22, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns details of the given battery
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdGet(batteryId: number, options?: any): AxiosPromise<BatteryDetailsResponse> {
            return localVarFp.batteriesBatteryIdGet(batteryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prints the grocycode label of the given battery on the configured label printer
         * @param {number} batteryId A valid battery id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesBatteryIdPrintlabelGet(batteryId: number, options?: any): AxiosPromise<object> {
            return localVarFp.batteriesBatteryIdPrintlabelGet(batteryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undoes a battery charge cycle
         * @param {number} chargeCycleId A valid charge cycle id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId: number, options?: any): AxiosPromise<void> {
            return localVarFp.batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all batteries incl. the next estimated charge time per battery
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batteriesGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<CurrentBatteryResponse>> {
            return localVarFp.batteriesGet(query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BatteriesApi - object-oriented interface
 * @export
 * @class BatteriesApi
 * @extends {BaseAPI}
 */
export class BatteriesApi extends BaseAPI {
    /**
     * 
     * @summary Tracks a charge cycle of the given battery
     * @param {number} batteryId A valid battery id
     * @param {InlineObject22} inlineObject22 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatteriesApi
     */
    public batteriesBatteryIdChargePost(batteryId: number, inlineObject22: InlineObject22, options?: AxiosRequestConfig) {
        return BatteriesApiFp(this.configuration).batteriesBatteryIdChargePost(batteryId, inlineObject22, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns details of the given battery
     * @param {number} batteryId A valid battery id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatteriesApi
     */
    public batteriesBatteryIdGet(batteryId: number, options?: AxiosRequestConfig) {
        return BatteriesApiFp(this.configuration).batteriesBatteryIdGet(batteryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prints the grocycode label of the given battery on the configured label printer
     * @param {number} batteryId A valid battery id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatteriesApi
     */
    public batteriesBatteryIdPrintlabelGet(batteryId: number, options?: AxiosRequestConfig) {
        return BatteriesApiFp(this.configuration).batteriesBatteryIdPrintlabelGet(batteryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undoes a battery charge cycle
     * @param {number} chargeCycleId A valid charge cycle id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatteriesApi
     */
    public batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId: number, options?: AxiosRequestConfig) {
        return BatteriesApiFp(this.configuration).batteriesChargeCyclesChargeCycleIdUndoPost(chargeCycleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all batteries incl. the next estimated charge time per battery
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BatteriesApi
     */
    public batteriesGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return BatteriesApiFp(this.configuration).batteriesGet(query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendar/ical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a (public) sharing link for the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalSharingLinkGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/calendar/ical/sharing-link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarIcalGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarIcalGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a (public) sharing link for the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calendarIcalSharingLinkGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calendarIcalSharingLinkGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalGet(options?: any): AxiosPromise<string> {
            return localVarFp.calendarIcalGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a (public) sharing link for the calendar in iCal format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calendarIcalSharingLinkGet(options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.calendarIcalSharingLinkGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * 
     * @summary Returns the calendar in iCal format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public calendarIcalGet(options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).calendarIcalGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a (public) sharing link for the calendar in iCal format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public calendarIcalSharingLinkGet(options?: AxiosRequestConfig) {
        return CalendarApiFp(this.configuration).calendarIcalSharingLinkGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ChoresApi - axios parameter creator
 * @export
 */
export const ChoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Tracks an execution of the given chore
         * @param {number} choreId A valid chore id
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdExecutePost: async (choreId: number, inlineObject20: InlineObject20, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choreId' is not null or undefined
            assertParamExists('choresChoreIdExecutePost', 'choreId', choreId)
            // verify required parameter 'inlineObject20' is not null or undefined
            assertParamExists('choresChoreIdExecutePost', 'inlineObject20', inlineObject20)
            const localVarPath = `/chores/{choreId}/execute`
                .replace(`{${"choreId"}}`, encodeURIComponent(String(choreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject20, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns details of the given chore
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdGet: async (choreId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choreId' is not null or undefined
            assertParamExists('choresChoreIdGet', 'choreId', choreId)
            const localVarPath = `/chores/{choreId}`
                .replace(`{${"choreId"}}`, encodeURIComponent(String(choreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prints the grocycode label of the given chore on the configured label printer
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdPrintlabelGet: async (choreId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choreId' is not null or undefined
            assertParamExists('choresChoreIdPrintlabelGet', 'choreId', choreId)
            const localVarPath = `/chores/{choreId}/printlabel`
                .replace(`{${"choreId"}}`, encodeURIComponent(String(choreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merges two chores into one
         * @param {number} choreIdToKeep A valid chore id of the chore to keep
         * @param {number} choreIdToRemove A valid chore id of the chore to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdToKeepMergeChoreIdToRemovePost: async (choreIdToKeep: number, choreIdToRemove: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'choreIdToKeep' is not null or undefined
            assertParamExists('choresChoreIdToKeepMergeChoreIdToRemovePost', 'choreIdToKeep', choreIdToKeep)
            // verify required parameter 'choreIdToRemove' is not null or undefined
            assertParamExists('choresChoreIdToKeepMergeChoreIdToRemovePost', 'choreIdToRemove', choreIdToRemove)
            const localVarPath = `/chores/{choreIdToKeep}/merge/{choreIdToRemove}`
                .replace(`{${"choreIdToKeep"}}`, encodeURIComponent(String(choreIdToKeep)))
                .replace(`{${"choreIdToRemove"}}`, encodeURIComponent(String(choreIdToRemove)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Re)calculates all next user assignments of all chores
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresExecutionsCalculateNextAssignmentsPost: async (inlineObject21?: InlineObject21, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chores/executions/calculate-next-assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject21, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undoes a chore execution
         * @param {number} executionId A valid chore execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresExecutionsExecutionIdUndoPost: async (executionId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executionId' is not null or undefined
            assertParamExists('choresExecutionsExecutionIdUndoPost', 'executionId', executionId)
            const localVarPath = `/chores/executions/{executionId}/undo`
                .replace(`{${"executionId"}}`, encodeURIComponent(String(executionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all chores incl. the next estimated execution time per chore
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresGet: async (query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChoresApi - functional programming interface
 * @export
 */
export const ChoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChoresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Tracks an execution of the given chore
         * @param {number} choreId A valid chore id
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresChoreIdExecutePost(choreId: number, inlineObject20: InlineObject20, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChoreLogEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresChoreIdExecutePost(choreId, inlineObject20, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns details of the given chore
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresChoreIdGet(choreId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChoreDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresChoreIdGet(choreId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prints the grocycode label of the given chore on the configured label printer
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresChoreIdPrintlabelGet(choreId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresChoreIdPrintlabelGet(choreId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merges two chores into one
         * @param {number} choreIdToKeep A valid chore id of the chore to keep
         * @param {number} choreIdToRemove A valid chore id of the chore to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep: number, choreIdToRemove: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep, choreIdToRemove, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary (Re)calculates all next user assignments of all chores
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresExecutionsCalculateNextAssignmentsPost(inlineObject21?: InlineObject21, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresExecutionsCalculateNextAssignmentsPost(inlineObject21, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undoes a chore execution
         * @param {number} executionId A valid chore execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresExecutionsExecutionIdUndoPost(executionId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresExecutionsExecutionIdUndoPost(executionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all chores incl. the next estimated execution time per chore
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async choresGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentChoreResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.choresGet(query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChoresApi - factory interface
 * @export
 */
export const ChoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChoresApiFp(configuration)
    return {
        /**
         * 
         * @summary Tracks an execution of the given chore
         * @param {number} choreId A valid chore id
         * @param {InlineObject20} inlineObject20 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdExecutePost(choreId: number, inlineObject20: InlineObject20, options?: any): AxiosPromise<ChoreLogEntry> {
            return localVarFp.choresChoreIdExecutePost(choreId, inlineObject20, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns details of the given chore
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdGet(choreId: number, options?: any): AxiosPromise<ChoreDetailsResponse> {
            return localVarFp.choresChoreIdGet(choreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prints the grocycode label of the given chore on the configured label printer
         * @param {number} choreId A valid chore id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdPrintlabelGet(choreId: number, options?: any): AxiosPromise<object> {
            return localVarFp.choresChoreIdPrintlabelGet(choreId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merges two chores into one
         * @param {number} choreIdToKeep A valid chore id of the chore to keep
         * @param {number} choreIdToRemove A valid chore id of the chore to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep: number, choreIdToRemove: number, options?: any): AxiosPromise<void> {
            return localVarFp.choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep, choreIdToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Re)calculates all next user assignments of all chores
         * @param {InlineObject21} [inlineObject21] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresExecutionsCalculateNextAssignmentsPost(inlineObject21?: InlineObject21, options?: any): AxiosPromise<void> {
            return localVarFp.choresExecutionsCalculateNextAssignmentsPost(inlineObject21, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undoes a chore execution
         * @param {number} executionId A valid chore execution id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresExecutionsExecutionIdUndoPost(executionId: number, options?: any): AxiosPromise<void> {
            return localVarFp.choresExecutionsExecutionIdUndoPost(executionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all chores incl. the next estimated execution time per chore
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        choresGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<CurrentChoreResponse>> {
            return localVarFp.choresGet(query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChoresApi - object-oriented interface
 * @export
 * @class ChoresApi
 * @extends {BaseAPI}
 */
export class ChoresApi extends BaseAPI {
    /**
     * 
     * @summary Tracks an execution of the given chore
     * @param {number} choreId A valid chore id
     * @param {InlineObject20} inlineObject20 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresChoreIdExecutePost(choreId: number, inlineObject20: InlineObject20, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresChoreIdExecutePost(choreId, inlineObject20, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns details of the given chore
     * @param {number} choreId A valid chore id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresChoreIdGet(choreId: number, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresChoreIdGet(choreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prints the grocycode label of the given chore on the configured label printer
     * @param {number} choreId A valid chore id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresChoreIdPrintlabelGet(choreId: number, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresChoreIdPrintlabelGet(choreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merges two chores into one
     * @param {number} choreIdToKeep A valid chore id of the chore to keep
     * @param {number} choreIdToRemove A valid chore id of the chore to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep: number, choreIdToRemove: number, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresChoreIdToKeepMergeChoreIdToRemovePost(choreIdToKeep, choreIdToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary (Re)calculates all next user assignments of all chores
     * @param {InlineObject21} [inlineObject21] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresExecutionsCalculateNextAssignmentsPost(inlineObject21?: InlineObject21, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresExecutionsCalculateNextAssignmentsPost(inlineObject21, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undoes a chore execution
     * @param {number} executionId A valid chore execution id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresExecutionsExecutionIdUndoPost(executionId: number, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresExecutionsExecutionIdUndoPost(executionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all chores incl. the next estimated execution time per chore
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChoresApi
     */
    public choresGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return ChoresApiFp(this.configuration).choresGet(query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CurrentUserApi - axios parameter creator
 * @export
 */
export const CurrentUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all settings of the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyDelete: async (settingKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingKey' is not null or undefined
            assertParamExists('userSettingsSettingKeyDelete', 'settingKey', settingKey)
            const localVarPath = `/user/settings/{settingKey}`
                .replace(`{${"settingKey"}}`, encodeURIComponent(String(settingKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyGet: async (settingKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingKey' is not null or undefined
            assertParamExists('userSettingsSettingKeyGet', 'settingKey', settingKey)
            const localVarPath = `/user/settings/{settingKey}`
                .replace(`{${"settingKey"}}`, encodeURIComponent(String(settingKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {UserSetting} userSetting A valid UserSetting object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyPut: async (settingKey: string, userSetting: UserSetting, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingKey' is not null or undefined
            assertParamExists('userSettingsSettingKeyPut', 'settingKey', settingKey)
            // verify required parameter 'userSetting' is not null or undefined
            assertParamExists('userSettingsSettingKeyPut', 'userSetting', userSetting)
            const localVarPath = `/user/settings/{settingKey}`
                .replace(`{${"settingKey"}}`, encodeURIComponent(String(settingKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSetting, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrentUserApi - functional programming interface
 * @export
 */
export const CurrentUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrentUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all settings of the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSettingsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSettingsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSettingsSettingKeyDelete(settingKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSettingsSettingKeyDelete(settingKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSettingsSettingKeyGet(settingKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSetting>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSettingsSettingKeyGet(settingKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {UserSetting} userSetting A valid UserSetting object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSettingsSettingKeyPut(settingKey: string, userSetting: UserSetting, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSettingsSettingKeyPut(settingKey, userSetting, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CurrentUserApi - factory interface
 * @export
 */
export const CurrentUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrentUserApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the currently authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(options?: any): AxiosPromise<Array<UserDto>> {
            return localVarFp.userGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all settings of the currently logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsGet(options?: any): AxiosPromise<object> {
            return localVarFp.userSettingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyDelete(settingKey: string, options?: any): AxiosPromise<void> {
            return localVarFp.userSettingsSettingKeyDelete(settingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyGet(settingKey: string, options?: any): AxiosPromise<UserSetting> {
            return localVarFp.userSettingsSettingKeyGet(settingKey, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets the given setting of the currently logged in user
         * @param {string} settingKey The key of the user setting
         * @param {UserSetting} userSetting A valid UserSetting object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSettingsSettingKeyPut(settingKey: string, userSetting: UserSetting, options?: any): AxiosPromise<void> {
            return localVarFp.userSettingsSettingKeyPut(settingKey, userSetting, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrentUserApi - object-oriented interface
 * @export
 * @class CurrentUserApi
 * @extends {BaseAPI}
 */
export class CurrentUserApi extends BaseAPI {
    /**
     * 
     * @summary Returns the currently authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userGet(options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).userGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all settings of the currently logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userSettingsGet(options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).userSettingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes the given setting of the currently logged in user
     * @param {string} settingKey The key of the user setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userSettingsSettingKeyDelete(settingKey: string, options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).userSettingsSettingKeyDelete(settingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the given setting of the currently logged in user
     * @param {string} settingKey The key of the user setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userSettingsSettingKeyGet(settingKey: string, options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).userSettingsSettingKeyGet(settingKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets the given setting of the currently logged in user
     * @param {string} settingKey The key of the user setting
     * @param {UserSetting} userSetting A valid UserSetting object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrentUserApi
     */
    public userSettingsSettingKeyPut(settingKey: string, userSetting: UserSetting, options?: AxiosRequestConfig) {
        return CurrentUserApiFp(this.configuration).userSettingsSettingKeyPut(settingKey, userSetting, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNameDelete: async (group: FileGroups, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('filesGroupFileNameDelete', 'group', group)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('filesGroupFileNameDelete', 'fileName', fileName)
            const localVarPath = `/files/{group}/{fileName}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With proper Content-Type header
         * @summary Serves the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {'picture'} [forceServeAs] Force the file to be served as the given type
         * @param {number} [bestFitHeight] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given height while maintaining the aspect ratio
         * @param {number} [bestFitWidth] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given width while maintaining the aspect ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNameGet: async (group: FileGroups, fileName: string, forceServeAs?: 'picture', bestFitHeight?: number, bestFitWidth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('filesGroupFileNameGet', 'group', group)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('filesGroupFileNameGet', 'fileName', fileName)
            const localVarPath = `/files/{group}/{fileName}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (forceServeAs !== undefined) {
                localVarQueryParameter['force_serve_as'] = forceServeAs;
            }

            if (bestFitHeight !== undefined) {
                localVarQueryParameter['best_fit_height'] = bestFitHeight;
            }

            if (bestFitWidth !== undefined) {
                localVarQueryParameter['best_fit_width'] = bestFitWidth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The file will be stored at /data/storage/{group}/{file_name} (you need to remember the group and file name to get or delete it again)
         * @summary Uploads a single file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNamePut: async (group: FileGroups, fileName: string, body?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('filesGroupFileNamePut', 'group', group)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('filesGroupFileNamePut', 'fileName', fileName)
            const localVarPath = `/files/{group}/{fileName}`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesGroupFileNameDelete(group: FileGroups, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesGroupFileNameDelete(group, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * With proper Content-Type header
         * @summary Serves the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {'picture'} [forceServeAs] Force the file to be served as the given type
         * @param {number} [bestFitHeight] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given height while maintaining the aspect ratio
         * @param {number} [bestFitWidth] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given width while maintaining the aspect ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesGroupFileNameGet(group: FileGroups, fileName: string, forceServeAs?: 'picture', bestFitHeight?: number, bestFitWidth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesGroupFileNameGet(group, fileName, forceServeAs, bestFitHeight, bestFitWidth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The file will be stored at /data/storage/{group}/{file_name} (you need to remember the group and file name to get or delete it again)
         * @summary Uploads a single file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async filesGroupFileNamePut(group: FileGroups, fileName: string, body?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.filesGroupFileNamePut(group, fileName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilesApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNameDelete(group: FileGroups, fileName: string, options?: any): AxiosPromise<void> {
            return localVarFp.filesGroupFileNameDelete(group, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * With proper Content-Type header
         * @summary Serves the given file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {'picture'} [forceServeAs] Force the file to be served as the given type
         * @param {number} [bestFitHeight] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given height while maintaining the aspect ratio
         * @param {number} [bestFitWidth] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given width while maintaining the aspect ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNameGet(group: FileGroups, fileName: string, forceServeAs?: 'picture', bestFitHeight?: number, bestFitWidth?: number, options?: any): AxiosPromise<any> {
            return localVarFp.filesGroupFileNameGet(group, fileName, forceServeAs, bestFitHeight, bestFitWidth, options).then((request) => request(axios, basePath));
        },
        /**
         * The file will be stored at /data/storage/{group}/{file_name} (you need to remember the group and file name to get or delete it again)
         * @summary Uploads a single file
         * @param {FileGroups} group The file group
         * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        filesGroupFileNamePut(group: FileGroups, fileName: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.filesGroupFileNamePut(group, fileName, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
    /**
     * 
     * @summary Deletes the given file
     * @param {FileGroups} group The file group
     * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesGroupFileNameDelete(group: FileGroups, fileName: string, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesGroupFileNameDelete(group, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * With proper Content-Type header
     * @summary Serves the given file
     * @param {FileGroups} group The file group
     * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
     * @param {'picture'} [forceServeAs] Force the file to be served as the given type
     * @param {number} [bestFitHeight] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given height while maintaining the aspect ratio
     * @param {number} [bestFitWidth] Only when using &#x60;force_serve_as&#x60; &#x3D; &#x60;picture&#x60;: Downscale the picture to the given width while maintaining the aspect ratio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesGroupFileNameGet(group: FileGroups, fileName: string, forceServeAs?: 'picture', bestFitHeight?: number, bestFitWidth?: number, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesGroupFileNameGet(group, fileName, forceServeAs, bestFitHeight, bestFitWidth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The file will be stored at /data/storage/{group}/{file_name} (you need to remember the group and file name to get or delete it again)
     * @summary Uploads a single file
     * @param {FileGroups} group The file group
     * @param {string} fileName The file name (including extension)&lt;br&gt;**BASE64 encoded**
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    public filesGroupFileNamePut(group: FileGroups, fileName: string, body?: any, options?: AxiosRequestConfig) {
        return FilesApiFp(this.configuration).filesGroupFileNamePut(group, fileName, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GenericEntityInteractionsApi - axios parameter creator
 * @export
 */
export const GenericEntityInteractionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all objects of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityGet: async (entity: ExposedEntityNotIncludingNotListable, query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('objectsEntityGet', 'entity', entity)
            const localVarPath = `/objects/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a single object of the given entity
         * @param {ExposedEntityNotIncludingNotDeletable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdDelete: async (entity: ExposedEntityNotIncludingNotDeletable, objectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('objectsEntityObjectIdDelete', 'entity', entity)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('objectsEntityObjectIdDelete', 'objectId', objectId)
            const localVarPath = `/objects/{entity}/{objectId}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a single object of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdGet: async (entity: ExposedEntityNotIncludingNotListable, objectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('objectsEntityObjectIdGet', 'entity', entity)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('objectsEntityObjectIdGet', 'objectId', objectId)
            const localVarPath = `/objects/{entity}/{objectId}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edits the given object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdPut: async (entity: ExposedEntityNotIncludingNotEditable, objectId: number, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('objectsEntityObjectIdPut', 'entity', entity)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('objectsEntityObjectIdPut', 'objectId', objectId)
            // verify required parameter 'productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode' is not null or undefined
            assertParamExists('objectsEntityObjectIdPut', 'productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode', productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode)
            const localVarPath = `/objects/{entity}/{objectId}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a single object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityPost: async (entity: ExposedEntityNotIncludingNotEditable, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('objectsEntityPost', 'entity', entity)
            // verify required parameter 'productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode' is not null or undefined
            assertParamExists('objectsEntityPost', 'productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode', productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode)
            const localVarPath = `/objects/{entity}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all userfields with their values of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntities} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userfieldsEntityObjectIdGet: async (entity: ExposedEntityIncludingUserEntities, objectId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('userfieldsEntityObjectIdGet', 'entity', entity)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userfieldsEntityObjectIdGet', 'objectId', objectId)
            const localVarPath = `/userfields/{entity}/{objectId}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edits the given userfields of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntitiesNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {} UNKNOWN_PARAM_NAME A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userfieldsEntityObjectIdPut: async (entity: ExposedEntityIncludingUserEntitiesNotIncludingNotEditable, objectId: number, UNKNOWN_PARAM_NAME: , options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entity' is not null or undefined
            assertParamExists('userfieldsEntityObjectIdPut', 'entity', entity)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('userfieldsEntityObjectIdPut', 'objectId', objectId)
            // verify required parameter 'UNKNOWN_PARAM_NAME' is not null or undefined
            assertParamExists('userfieldsEntityObjectIdPut', 'UNKNOWN_PARAM_NAME', UNKNOWN_PARAM_NAME)
            const localVarPath = `/userfields/{entity}/{objectId}`
                .replace(`{${"entity"}}`, encodeURIComponent(String(entity)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(UNKNOWN_PARAM_NAME, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GenericEntityInteractionsApi - functional programming interface
 * @export
 */
export const GenericEntityInteractionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GenericEntityInteractionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all objects of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objectsEntityGet(entity: ExposedEntityNotIncludingNotListable, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objectsEntityGet(entity, query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a single object of the given entity
         * @param {ExposedEntityNotIncludingNotDeletable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objectsEntityObjectIdDelete(entity: ExposedEntityNotIncludingNotDeletable, objectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objectsEntityObjectIdDelete(entity, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a single object of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objectsEntityObjectIdGet(entity: ExposedEntityNotIncludingNotListable, objectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objectsEntityObjectIdGet(entity, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edits the given object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objectsEntityObjectIdPut(entity: ExposedEntityNotIncludingNotEditable, objectId: number, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objectsEntityObjectIdPut(entity, objectId, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a single object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async objectsEntityPost(entity: ExposedEntityNotIncludingNotEditable, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.objectsEntityPost(entity, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all userfields with their values of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntities} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userfieldsEntityObjectIdGet(entity: ExposedEntityIncludingUserEntities, objectId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userfieldsEntityObjectIdGet(entity, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edits the given userfields of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntitiesNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {} UNKNOWN_PARAM_NAME A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userfieldsEntityObjectIdPut(entity: ExposedEntityIncludingUserEntitiesNotIncludingNotEditable, objectId: number, UNKNOWN_PARAM_NAME: , options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userfieldsEntityObjectIdPut(entity, objectId, UNKNOWN_PARAM_NAME, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GenericEntityInteractionsApi - factory interface
 * @export
 */
export const GenericEntityInteractionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GenericEntityInteractionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all objects of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityGet(entity: ExposedEntityNotIncludingNotListable, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode>> {
            return localVarFp.objectsEntityGet(entity, query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a single object of the given entity
         * @param {ExposedEntityNotIncludingNotDeletable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdDelete(entity: ExposedEntityNotIncludingNotDeletable, objectId: number, options?: any): AxiosPromise<void> {
            return localVarFp.objectsEntityObjectIdDelete(entity, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a single object of the given entity
         * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdGet(entity: ExposedEntityNotIncludingNotListable, objectId: number, options?: any): AxiosPromise<Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode> {
            return localVarFp.objectsEntityObjectIdGet(entity, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edits the given object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityObjectIdPut(entity: ExposedEntityNotIncludingNotEditable, objectId: number, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: any): AxiosPromise<void> {
            return localVarFp.objectsEntityObjectIdPut(entity, objectId, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a single object of the given entity
         * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
         * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        objectsEntityPost(entity: ExposedEntityNotIncludingNotEditable, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.objectsEntityPost(entity, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all userfields with their values of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntities} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userfieldsEntityObjectIdGet(entity: ExposedEntityIncludingUserEntities, objectId: number, options?: any): AxiosPromise<object> {
            return localVarFp.userfieldsEntityObjectIdGet(entity, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edits the given userfields of the given object of the given entity
         * @param {ExposedEntityIncludingUserEntitiesNotIncludingNotEditable} entity A valid entity name
         * @param {number} objectId A valid object id of the given entity
         * @param {} UNKNOWN_PARAM_NAME A valid entity object of the entity specified in parameter *entity*
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userfieldsEntityObjectIdPut(entity: ExposedEntityIncludingUserEntitiesNotIncludingNotEditable, objectId: number, UNKNOWN_PARAM_NAME: , options?: any): AxiosPromise<void> {
            return localVarFp.userfieldsEntityObjectIdPut(entity, objectId, UNKNOWN_PARAM_NAME, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GenericEntityInteractionsApi - object-oriented interface
 * @export
 * @class GenericEntityInteractionsApi
 * @extends {BaseAPI}
 */
export class GenericEntityInteractionsApi extends BaseAPI {
    /**
     * 
     * @summary Returns all objects of the given entity
     * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public objectsEntityGet(entity: ExposedEntityNotIncludingNotListable, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).objectsEntityGet(entity, query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a single object of the given entity
     * @param {ExposedEntityNotIncludingNotDeletable} entity A valid entity name
     * @param {number} objectId A valid object id of the given entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public objectsEntityObjectIdDelete(entity: ExposedEntityNotIncludingNotDeletable, objectId: number, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).objectsEntityObjectIdDelete(entity, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a single object of the given entity
     * @param {ExposedEntityNotIncludingNotListable} entity A valid entity name
     * @param {number} objectId A valid object id of the given entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public objectsEntityObjectIdGet(entity: ExposedEntityNotIncludingNotListable, objectId: number, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).objectsEntityObjectIdGet(entity, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edits the given object of the given entity
     * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
     * @param {number} objectId A valid object id of the given entity
     * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public objectsEntityObjectIdPut(entity: ExposedEntityNotIncludingNotEditable, objectId: number, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).objectsEntityObjectIdPut(entity, objectId, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a single object of the given entity
     * @param {ExposedEntityNotIncludingNotEditable} entity A valid entity name
     * @param {Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode} productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode A valid entity object of the entity specified in parameter *entity*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public objectsEntityPost(entity: ExposedEntityNotIncludingNotEditable, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode: Product | Chore | Battery | Location | QuantityUnit | ShoppingListItem | StockEntry | ProductBarcode, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).objectsEntityPost(entity, productChoreBatteryLocationQuantityUnitShoppingListItemStockEntryProductBarcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all userfields with their values of the given object of the given entity
     * @param {ExposedEntityIncludingUserEntities} entity A valid entity name
     * @param {number} objectId A valid object id of the given entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public userfieldsEntityObjectIdGet(entity: ExposedEntityIncludingUserEntities, objectId: number, options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).userfieldsEntityObjectIdGet(entity, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edits the given userfields of the given object of the given entity
     * @param {ExposedEntityIncludingUserEntitiesNotIncludingNotEditable} entity A valid entity name
     * @param {number} objectId A valid object id of the given entity
     * @param {} UNKNOWN_PARAM_NAME A valid entity object of the entity specified in parameter *entity*
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GenericEntityInteractionsApi
     */
    public userfieldsEntityObjectIdPut(entity: ExposedEntityIncludingUserEntitiesNotIncludingNotEditable, objectId: number, UNKNOWN_PARAM_NAME: , options?: AxiosRequestConfig) {
        return GenericEntityInteractionsApiFp(this.configuration).userfieldsEntityObjectIdPut(entity, objectId, UNKNOWN_PARAM_NAME, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PrintApi - axios parameter creator
 * @export
 */
export const PrintApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Prints the shoppinglist with a thermal printer
         * @param {number} [list] Shopping list id
         * @param {boolean} [printHeader] Prints grocy logo if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printShoppinglistThermalGet: async (list?: number, printHeader?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/print/shoppinglist/thermal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (list !== undefined) {
                localVarQueryParameter['list'] = list;
            }

            if (printHeader !== undefined) {
                localVarQueryParameter['printHeader'] = printHeader;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PrintApi - functional programming interface
 * @export
 */
export const PrintApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PrintApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Prints the shoppinglist with a thermal printer
         * @param {number} [list] Shopping list id
         * @param {boolean} [printHeader] Prints grocy logo if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async printShoppinglistThermalGet(list?: number, printHeader?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.printShoppinglistThermalGet(list, printHeader, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PrintApi - factory interface
 * @export
 */
export const PrintApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PrintApiFp(configuration)
    return {
        /**
         * 
         * @summary Prints the shoppinglist with a thermal printer
         * @param {number} [list] Shopping list id
         * @param {boolean} [printHeader] Prints grocy logo if true
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        printShoppinglistThermalGet(list?: number, printHeader?: boolean, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.printShoppinglistThermalGet(list, printHeader, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PrintApi - object-oriented interface
 * @export
 * @class PrintApi
 * @extends {BaseAPI}
 */
export class PrintApi extends BaseAPI {
    /**
     * 
     * @summary Prints the shoppinglist with a thermal printer
     * @param {number} [list] Shopping list id
     * @param {boolean} [printHeader] Prints grocy logo if true
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PrintApi
     */
    public printShoppinglistThermalGet(list?: number, printHeader?: boolean, options?: AxiosRequestConfig) {
        return PrintApiFp(this.configuration).printShoppinglistThermalGet(list, printHeader, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecipesApi - axios parameter creator
 * @export
 */
export const RecipesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get stock fulfillment information for all recipe
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesFulfillmentGet: async (query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/recipes/fulfillment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds all missing products for the given recipe to the shopping list
         * @param {string} recipeId A valid recipe id
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost: async (recipeId: string, inlineObject19?: InlineObject19, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipeId}/add-not-fulfilled-products-to-shoppinglist`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject19, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Consumes all products of the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdConsumePost: async (recipeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('recipesRecipeIdConsumePost', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipeId}/consume`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies a recipe
         * @param {number} recipeId A valid recipe id of the recipe to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdCopyPost: async (recipeId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('recipesRecipeIdCopyPost', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipeId}/copy`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get stock fulfillment information for the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdFulfillmentGet: async (recipeId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('recipesRecipeIdFulfillmentGet', 'recipeId', recipeId)
            const localVarPath = `/recipes/{recipeId}/fulfillment`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipesApi - functional programming interface
 * @export
 */
export const RecipesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecipesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get stock fulfillment information for all recipe
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipesFulfillmentGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeFulfillmentResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipesFulfillmentGet(query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds all missing products for the given recipe to the shopping list
         * @param {string} recipeId A valid recipe id
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId: string, inlineObject19?: InlineObject19, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId, inlineObject19, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Consumes all products of the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipesRecipeIdConsumePost(recipeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipesRecipeIdConsumePost(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Copies a recipe
         * @param {number} recipeId A valid recipe id of the recipe to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipesRecipeIdCopyPost(recipeId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipesRecipeIdCopyPost(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get stock fulfillment information for the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recipesRecipeIdFulfillmentGet(recipeId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeFulfillmentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recipesRecipeIdFulfillmentGet(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecipesApi - factory interface
 * @export
 */
export const RecipesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecipesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get stock fulfillment information for all recipe
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesFulfillmentGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<RecipeFulfillmentResponse>> {
            return localVarFp.recipesFulfillmentGet(query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds all missing products for the given recipe to the shopping list
         * @param {string} recipeId A valid recipe id
         * @param {InlineObject19} [inlineObject19] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId: string, inlineObject19?: InlineObject19, options?: any): AxiosPromise<void> {
            return localVarFp.recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId, inlineObject19, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Consumes all products of the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdConsumePost(recipeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recipesRecipeIdConsumePost(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Copies a recipe
         * @param {number} recipeId A valid recipe id of the recipe to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdCopyPost(recipeId: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.recipesRecipeIdCopyPost(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get stock fulfillment information for the given recipe
         * @param {string} recipeId A valid recipe id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recipesRecipeIdFulfillmentGet(recipeId: string, options?: any): AxiosPromise<RecipeFulfillmentResponse> {
            return localVarFp.recipesRecipeIdFulfillmentGet(recipeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecipesApi - object-oriented interface
 * @export
 * @class RecipesApi
 * @extends {BaseAPI}
 */
export class RecipesApi extends BaseAPI {
    /**
     * 
     * @summary Get stock fulfillment information for all recipe
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public recipesFulfillmentGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return RecipesApiFp(this.configuration).recipesFulfillmentGet(query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds all missing products for the given recipe to the shopping list
     * @param {string} recipeId A valid recipe id
     * @param {InlineObject19} [inlineObject19] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId: string, inlineObject19?: InlineObject19, options?: AxiosRequestConfig) {
        return RecipesApiFp(this.configuration).recipesRecipeIdAddNotFulfilledProductsToShoppinglistPost(recipeId, inlineObject19, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Consumes all products of the given recipe
     * @param {string} recipeId A valid recipe id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public recipesRecipeIdConsumePost(recipeId: string, options?: AxiosRequestConfig) {
        return RecipesApiFp(this.configuration).recipesRecipeIdConsumePost(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Copies a recipe
     * @param {number} recipeId A valid recipe id of the recipe to copy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public recipesRecipeIdCopyPost(recipeId: number, options?: AxiosRequestConfig) {
        return RecipesApiFp(this.configuration).recipesRecipeIdCopyPost(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get stock fulfillment information for the given recipe
     * @param {string} recipeId A valid recipe id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipesApi
     */
    public recipesRecipeIdFulfillmentGet(recipeId: string, options?: AxiosRequestConfig) {
        return RecipesApiFp(this.configuration).recipesRecipeIdFulfillmentGet(recipeId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockApi - axios parameter creator
 * @export
 */
export const StockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Executes an external barcode lookoup via the configured plugin with the given barcode
         * @param {string} barcode The barcode to lookup up
         * @param {boolean} [add] When true, the product is added to the database on a successful lookup and the new product id is in included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBarcodesExternalLookupBarcodeGet: async (barcode: string, add?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockBarcodesExternalLookupBarcodeGet', 'barcode', barcode)
            const localVarPath = `/stock/barcodes/external-lookup/{barcode}`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (add !== undefined) {
                localVarQueryParameter['add'] = add;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the given stock booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBookingsBookingIdGet: async (bookingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookingId' is not null or undefined
            assertParamExists('stockBookingsBookingIdGet', 'bookingId', bookingId)
            const localVarPath = `/stock/bookings/{bookingId}`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undoes a booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBookingsBookingIdUndoPost: async (bookingId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookingId' is not null or undefined
            assertParamExists('stockBookingsBookingIdUndoPost', 'bookingId', bookingId)
            const localVarPath = `/stock/bookings/{bookingId}/undo`
                .replace(`{${"bookingId"}}`, encodeURIComponent(String(bookingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns details of the given stock
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdGet: async (entryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('stockEntryEntryIdGet', 'entryId', entryId)
            const localVarPath = `/stock/entry/{entryId}`
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prints the grocycode / stock entry label of the given entry on the configured label printer
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdPrintlabelGet: async (entryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('stockEntryEntryIdPrintlabelGet', 'entryId', entryId)
            const localVarPath = `/stock/entry/{entryId}/printlabel`
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edits the stock entry
         * @param {number} entryId A valid stock entry id
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdPut: async (entryId: number, inlineObject2: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entryId' is not null or undefined
            assertParamExists('stockEntryEntryIdPut', 'entryId', entryId)
            // verify required parameter 'inlineObject2' is not null or undefined
            assertParamExists('stockEntryEntryIdPut', 'inlineObject2', inlineObject2)
            const localVarPath = `/stock/entry/{entryId}`
                .replace(`{${"entryId"}}`, encodeURIComponent(String(entryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all products which are currently in stock incl. the next due date per product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds the given amount of the given product to stock
         * @param {number} productId A valid product id
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdAddPost: async (productId: number, inlineObject3: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdAddPost', 'productId', productId)
            // verify required parameter 'inlineObject3' is not null or undefined
            assertParamExists('stockProductsProductIdAddPost', 'inlineObject3', inlineObject3)
            const localVarPath = `/stock/products/{productId}/add`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes the given amount of the given product from stock
         * @param {number} productId A valid product id
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdConsumePost: async (productId: number, inlineObject4: InlineObject4, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdConsumePost', 'productId', productId)
            // verify required parameter 'inlineObject4' is not null or undefined
            assertParamExists('stockProductsProductIdConsumePost', 'inlineObject4', inlineObject4)
            const localVarPath = `/stock/products/{productId}/consume`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject4, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all stock entries of the given product in order of next use (Opened first, then first due first, then first in first out)
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub products should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdEntriesGet: async (productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdEntriesGet', 'productId', productId)
            const localVarPath = `/stock/products/{productId}/entries`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (includeSubProducts !== undefined) {
                localVarQueryParameter['include_sub_products'] = includeSubProducts;
            }

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns details of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdGet: async (productId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdGet', 'productId', productId)
            const localVarPath = `/stock/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inventories the given product (adds/removes based on the given new amount)
         * @param {number} productId A valid product id
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdInventoryPost: async (productId: number, inlineObject6: InlineObject6, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdInventoryPost', 'productId', productId)
            // verify required parameter 'inlineObject6' is not null or undefined
            assertParamExists('stockProductsProductIdInventoryPost', 'inlineObject6', inlineObject6)
            const localVarPath = `/stock/products/{productId}/inventory`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject6, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all locations where the given product currently has stock
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub product locations should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdLocationsGet: async (productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdLocationsGet', 'productId', productId)
            const localVarPath = `/stock/products/{productId}/locations`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (includeSubProducts !== undefined) {
                localVarQueryParameter['include_sub_products'] = includeSubProducts;
            }

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks the given amount of the given product as opened
         * @param {number} productId A valid product id
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdOpenPost: async (productId: number, inlineObject7: InlineObject7, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdOpenPost', 'productId', productId)
            // verify required parameter 'inlineObject7' is not null or undefined
            assertParamExists('stockProductsProductIdOpenPost', 'inlineObject7', inlineObject7)
            const localVarPath = `/stock/products/{productId}/open`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject7, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the price history of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdPriceHistoryGet: async (productId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdPriceHistoryGet', 'productId', productId)
            const localVarPath = `/stock/products/{productId}/price-history`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prints the grocycode label of the given product on the configured label printer
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdPrintlabelGet: async (productId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdPrintlabelGet', 'productId', productId)
            const localVarPath = `/stock/products/{productId}/printlabel`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merges two products into one
         * @param {number} productIdToKeep A valid product id of the product to keep
         * @param {number} productIdToRemove A valid product id of the product to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdToKeepMergeProductIdToRemovePost: async (productIdToKeep: number, productIdToRemove: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productIdToKeep' is not null or undefined
            assertParamExists('stockProductsProductIdToKeepMergeProductIdToRemovePost', 'productIdToKeep', productIdToKeep)
            // verify required parameter 'productIdToRemove' is not null or undefined
            assertParamExists('stockProductsProductIdToKeepMergeProductIdToRemovePost', 'productIdToRemove', productIdToRemove)
            const localVarPath = `/stock/products/{productIdToKeep}/merge/{productIdToRemove}`
                .replace(`{${"productIdToKeep"}}`, encodeURIComponent(String(productIdToKeep)))
                .replace(`{${"productIdToRemove"}}`, encodeURIComponent(String(productIdToRemove)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfers the given amount of the given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {number} productId A valid product id
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdTransferPost: async (productId: number, inlineObject5: InlineObject5, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('stockProductsProductIdTransferPost', 'productId', productId)
            // verify required parameter 'inlineObject5' is not null or undefined
            assertParamExists('stockProductsProductIdTransferPost', 'inlineObject5', inlineObject5)
            const localVarPath = `/stock/products/{productId}/transfer`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject5, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds expired products to the given shopping list
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddExpiredProductsPost: async (inlineObject15?: InlineObject15, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock/shoppinglist/add-expired-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject15, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds currently missing products (below defined min. stock amount) to the given shopping list
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddMissingProductsPost: async (inlineObject13?: InlineObject13, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock/shoppinglist/add-missing-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject13, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds overdue products to the given shopping list
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddOverdueProductsPost: async (inlineObject14?: InlineObject14, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock/shoppinglist/add-overdue-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject14, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the product is already on the shopping list, the given amount will increase the amount of the already existing item, otherwise a new item will be added
         * @summary Adds the given amount of the given product to the given shopping list
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddProductPost: async (inlineObject17: InlineObject17, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject17' is not null or undefined
            assertParamExists('stockShoppinglistAddProductPost', 'inlineObject17', inlineObject17)
            const localVarPath = `/stock/shoppinglist/add-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject17, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes all items from the given shopping list
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistClearPost: async (inlineObject16?: InlineObject16, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock/shoppinglist/clear`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject16, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If the resulting amount is <= 0, the item will be completely removed from the given list, otherwise the given amount will reduce the amount of the existing item
         * @summary Removes the given amount of the given product from the given shopping list, if it is on it
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistRemoveProductPost: async (inlineObject18: InlineObject18, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject18' is not null or undefined
            assertParamExists('stockShoppinglistRemoveProductPost', 'inlineObject18', inlineObject18)
            const localVarPath = `/stock/shoppinglist/remove-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject18, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all stock bookings of the given transaction id
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockTransactionsTransactionIdGet: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('stockTransactionsTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/stock/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Undoes a transaction
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockTransactionsTransactionIdUndoPost: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('stockTransactionsTransactionIdUndoPost', 'transactionId', transactionId)
            const localVarPath = `/stock/transactions/{transactionId}/undo`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all products which are due soon, overdue, expired or currently missing
         * @param {number} [dueSoonDays] The number of days in which products are considered to be due soon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockVolatileGet: async (dueSoonDays?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stock/volatile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (dueSoonDays !== undefined) {
                localVarQueryParameter['due_soon_days'] = dueSoonDays;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockApi - functional programming interface
 * @export
 */
export const StockApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Executes an external barcode lookoup via the configured plugin with the given barcode
         * @param {string} barcode The barcode to lookup up
         * @param {boolean} [add] When true, the product is added to the database on a successful lookup and the new product id is in included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockBarcodesExternalLookupBarcodeGet(barcode: string, add?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalBarcodeLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockBarcodesExternalLookupBarcodeGet(barcode, add, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the given stock booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockBookingsBookingIdGet(bookingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockLogEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockBookingsBookingIdGet(bookingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undoes a booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockBookingsBookingIdUndoPost(bookingId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockBookingsBookingIdUndoPost(bookingId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns details of the given stock
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockEntryEntryIdGet(entryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockEntryEntryIdGet(entryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prints the grocycode / stock entry label of the given entry on the configured label printer
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockEntryEntryIdPrintlabelGet(entryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockEntryEntryIdPrintlabelGet(entryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edits the stock entry
         * @param {number} entryId A valid stock entry id
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockEntryEntryIdPut(entryId: number, inlineObject2: InlineObject2, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockEntryEntryIdPut(entryId, inlineObject2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all products which are currently in stock incl. the next due date per product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentStockResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds the given amount of the given product to stock
         * @param {number} productId A valid product id
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdAddPost(productId: number, inlineObject3: InlineObject3, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdAddPost(productId, inlineObject3, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes the given amount of the given product from stock
         * @param {number} productId A valid product id
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdConsumePost(productId: number, inlineObject4: InlineObject4, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdConsumePost(productId, inlineObject4, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all stock entries of the given product in order of next use (Opened first, then first due first, then first in first out)
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub products should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdEntriesGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdEntriesGet(productId, includeSubProducts, query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns details of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdGet(productId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inventories the given product (adds/removes based on the given new amount)
         * @param {number} productId A valid product id
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdInventoryPost(productId: number, inlineObject6: InlineObject6, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdInventoryPost(productId, inlineObject6, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all locations where the given product currently has stock
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub product locations should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdLocationsGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdLocationsGet(productId, includeSubProducts, query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Marks the given amount of the given product as opened
         * @param {number} productId A valid product id
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdOpenPost(productId: number, inlineObject7: InlineObject7, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdOpenPost(productId, inlineObject7, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the price history of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdPriceHistoryGet(productId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductPriceHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdPriceHistoryGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prints the grocycode label of the given product on the configured label printer
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdPrintlabelGet(productId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdPrintlabelGet(productId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Merges two products into one
         * @param {number} productIdToKeep A valid product id of the product to keep
         * @param {number} productIdToRemove A valid product id of the product to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep: number, productIdToRemove: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep, productIdToRemove, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfers the given amount of the given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {number} productId A valid product id
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsProductIdTransferPost(productId: number, inlineObject5: InlineObject5, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsProductIdTransferPost(productId, inlineObject5, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds expired products to the given shopping list
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistAddExpiredProductsPost(inlineObject15?: InlineObject15, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistAddExpiredProductsPost(inlineObject15, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds currently missing products (below defined min. stock amount) to the given shopping list
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistAddMissingProductsPost(inlineObject13?: InlineObject13, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistAddMissingProductsPost(inlineObject13, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds overdue products to the given shopping list
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistAddOverdueProductsPost(inlineObject14?: InlineObject14, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistAddOverdueProductsPost(inlineObject14, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the product is already on the shopping list, the given amount will increase the amount of the already existing item, otherwise a new item will be added
         * @summary Adds the given amount of the given product to the given shopping list
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistAddProductPost(inlineObject17: InlineObject17, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistAddProductPost(inlineObject17, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes all items from the given shopping list
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistClearPost(inlineObject16?: InlineObject16, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistClearPost(inlineObject16, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * If the resulting amount is <= 0, the item will be completely removed from the given list, otherwise the given amount will reduce the amount of the existing item
         * @summary Removes the given amount of the given product from the given shopping list, if it is on it
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockShoppinglistRemoveProductPost(inlineObject18: InlineObject18, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockShoppinglistRemoveProductPost(inlineObject18, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all stock bookings of the given transaction id
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockTransactionsTransactionIdGet(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockTransactionsTransactionIdGet(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Undoes a transaction
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockTransactionsTransactionIdUndoPost(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockTransactionsTransactionIdUndoPost(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all products which are due soon, overdue, expired or currently missing
         * @param {number} [dueSoonDays] The number of days in which products are considered to be due soon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockVolatileGet(dueSoonDays?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentVolatilStockResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockVolatileGet(dueSoonDays, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockApi - factory interface
 * @export
 */
export const StockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockApiFp(configuration)
    return {
        /**
         * 
         * @summary Executes an external barcode lookoup via the configured plugin with the given barcode
         * @param {string} barcode The barcode to lookup up
         * @param {boolean} [add] When true, the product is added to the database on a successful lookup and the new product id is in included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBarcodesExternalLookupBarcodeGet(barcode: string, add?: boolean, options?: any): AxiosPromise<ExternalBarcodeLookupResponse> {
            return localVarFp.stockBarcodesExternalLookupBarcodeGet(barcode, add, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the given stock booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBookingsBookingIdGet(bookingId: number, options?: any): AxiosPromise<StockLogEntry> {
            return localVarFp.stockBookingsBookingIdGet(bookingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undoes a booking
         * @param {number} bookingId A valid stock booking id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockBookingsBookingIdUndoPost(bookingId: number, options?: any): AxiosPromise<void> {
            return localVarFp.stockBookingsBookingIdUndoPost(bookingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns details of the given stock
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdGet(entryId: number, options?: any): AxiosPromise<StockEntry> {
            return localVarFp.stockEntryEntryIdGet(entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prints the grocycode / stock entry label of the given entry on the configured label printer
         * @param {number} entryId A valid stock entry id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdPrintlabelGet(entryId: number, options?: any): AxiosPromise<object> {
            return localVarFp.stockEntryEntryIdPrintlabelGet(entryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edits the stock entry
         * @param {number} entryId A valid stock entry id
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockEntryEntryIdPut(entryId: number, inlineObject2: InlineObject2, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockEntryEntryIdPut(entryId, inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all products which are currently in stock incl. the next due date per product
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockGet(options?: any): AxiosPromise<Array<CurrentStockResponse>> {
            return localVarFp.stockGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds the given amount of the given product to stock
         * @param {number} productId A valid product id
         * @param {InlineObject3} inlineObject3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdAddPost(productId: number, inlineObject3: InlineObject3, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsProductIdAddPost(productId, inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes the given amount of the given product from stock
         * @param {number} productId A valid product id
         * @param {InlineObject4} inlineObject4 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdConsumePost(productId: number, inlineObject4: InlineObject4, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsProductIdConsumePost(productId, inlineObject4, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all stock entries of the given product in order of next use (Opened first, then first due first, then first in first out)
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub products should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdEntriesGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<StockEntry>> {
            return localVarFp.stockProductsProductIdEntriesGet(productId, includeSubProducts, query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns details of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdGet(productId: number, options?: any): AxiosPromise<ProductDetailsResponse> {
            return localVarFp.stockProductsProductIdGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inventories the given product (adds/removes based on the given new amount)
         * @param {number} productId A valid product id
         * @param {InlineObject6} inlineObject6 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdInventoryPost(productId: number, inlineObject6: InlineObject6, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsProductIdInventoryPost(productId, inlineObject6, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all locations where the given product currently has stock
         * @param {number} productId A valid product id
         * @param {boolean} [includeSubProducts] If sub product locations should be included (if the given product is a parent product and in addition to the ones of the given product)
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdLocationsGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<StockLocation>> {
            return localVarFp.stockProductsProductIdLocationsGet(productId, includeSubProducts, query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks the given amount of the given product as opened
         * @param {number} productId A valid product id
         * @param {InlineObject7} inlineObject7 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdOpenPost(productId: number, inlineObject7: InlineObject7, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsProductIdOpenPost(productId, inlineObject7, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the price history of the given product
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdPriceHistoryGet(productId: number, options?: any): AxiosPromise<Array<ProductPriceHistory>> {
            return localVarFp.stockProductsProductIdPriceHistoryGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prints the grocycode label of the given product on the configured label printer
         * @param {number} productId A valid product id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdPrintlabelGet(productId: number, options?: any): AxiosPromise<object> {
            return localVarFp.stockProductsProductIdPrintlabelGet(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merges two products into one
         * @param {number} productIdToKeep A valid product id of the product to keep
         * @param {number} productIdToRemove A valid product id of the product to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep: number, productIdToRemove: number, options?: any): AxiosPromise<void> {
            return localVarFp.stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep, productIdToRemove, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfers the given amount of the given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {number} productId A valid product id
         * @param {InlineObject5} inlineObject5 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsProductIdTransferPost(productId: number, inlineObject5: InlineObject5, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsProductIdTransferPost(productId, inlineObject5, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds expired products to the given shopping list
         * @param {InlineObject15} [inlineObject15] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddExpiredProductsPost(inlineObject15?: InlineObject15, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistAddExpiredProductsPost(inlineObject15, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds currently missing products (below defined min. stock amount) to the given shopping list
         * @param {InlineObject13} [inlineObject13] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddMissingProductsPost(inlineObject13?: InlineObject13, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistAddMissingProductsPost(inlineObject13, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds overdue products to the given shopping list
         * @param {InlineObject14} [inlineObject14] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddOverdueProductsPost(inlineObject14?: InlineObject14, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistAddOverdueProductsPost(inlineObject14, options).then((request) => request(axios, basePath));
        },
        /**
         * If the product is already on the shopping list, the given amount will increase the amount of the already existing item, otherwise a new item will be added
         * @summary Adds the given amount of the given product to the given shopping list
         * @param {InlineObject17} inlineObject17 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistAddProductPost(inlineObject17: InlineObject17, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistAddProductPost(inlineObject17, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes all items from the given shopping list
         * @param {InlineObject16} [inlineObject16] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistClearPost(inlineObject16?: InlineObject16, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistClearPost(inlineObject16, options).then((request) => request(axios, basePath));
        },
        /**
         * If the resulting amount is <= 0, the item will be completely removed from the given list, otherwise the given amount will reduce the amount of the existing item
         * @summary Removes the given amount of the given product from the given shopping list, if it is on it
         * @param {InlineObject18} inlineObject18 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockShoppinglistRemoveProductPost(inlineObject18: InlineObject18, options?: any): AxiosPromise<void> {
            return localVarFp.stockShoppinglistRemoveProductPost(inlineObject18, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all stock bookings of the given transaction id
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockTransactionsTransactionIdGet(transactionId: string, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockTransactionsTransactionIdGet(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Undoes a transaction
         * @param {string} transactionId A valid stock transaction id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockTransactionsTransactionIdUndoPost(transactionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.stockTransactionsTransactionIdUndoPost(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all products which are due soon, overdue, expired or currently missing
         * @param {number} [dueSoonDays] The number of days in which products are considered to be due soon
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockVolatileGet(dueSoonDays?: number, options?: any): AxiosPromise<Array<CurrentVolatilStockResponse>> {
            return localVarFp.stockVolatileGet(dueSoonDays, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockApi - object-oriented interface
 * @export
 * @class StockApi
 * @extends {BaseAPI}
 */
export class StockApi extends BaseAPI {
    /**
     * 
     * @summary Executes an external barcode lookoup via the configured plugin with the given barcode
     * @param {string} barcode The barcode to lookup up
     * @param {boolean} [add] When true, the product is added to the database on a successful lookup and the new product id is in included in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockBarcodesExternalLookupBarcodeGet(barcode: string, add?: boolean, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockBarcodesExternalLookupBarcodeGet(barcode, add, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the given stock booking
     * @param {number} bookingId A valid stock booking id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockBookingsBookingIdGet(bookingId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockBookingsBookingIdGet(bookingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undoes a booking
     * @param {number} bookingId A valid stock booking id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockBookingsBookingIdUndoPost(bookingId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockBookingsBookingIdUndoPost(bookingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns details of the given stock
     * @param {number} entryId A valid stock entry id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockEntryEntryIdGet(entryId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockEntryEntryIdGet(entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prints the grocycode / stock entry label of the given entry on the configured label printer
     * @param {number} entryId A valid stock entry id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockEntryEntryIdPrintlabelGet(entryId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockEntryEntryIdPrintlabelGet(entryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edits the stock entry
     * @param {number} entryId A valid stock entry id
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockEntryEntryIdPut(entryId: number, inlineObject2: InlineObject2, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockEntryEntryIdPut(entryId, inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all products which are currently in stock incl. the next due date per product
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockGet(options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds the given amount of the given product to stock
     * @param {number} productId A valid product id
     * @param {InlineObject3} inlineObject3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdAddPost(productId: number, inlineObject3: InlineObject3, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdAddPost(productId, inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes the given amount of the given product from stock
     * @param {number} productId A valid product id
     * @param {InlineObject4} inlineObject4 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdConsumePost(productId: number, inlineObject4: InlineObject4, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdConsumePost(productId, inlineObject4, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all stock entries of the given product in order of next use (Opened first, then first due first, then first in first out)
     * @param {number} productId A valid product id
     * @param {boolean} [includeSubProducts] If sub products should be included (if the given product is a parent product and in addition to the ones of the given product)
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdEntriesGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdEntriesGet(productId, includeSubProducts, query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns details of the given product
     * @param {number} productId A valid product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdGet(productId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inventories the given product (adds/removes based on the given new amount)
     * @param {number} productId A valid product id
     * @param {InlineObject6} inlineObject6 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdInventoryPost(productId: number, inlineObject6: InlineObject6, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdInventoryPost(productId, inlineObject6, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all locations where the given product currently has stock
     * @param {number} productId A valid product id
     * @param {boolean} [includeSubProducts] If sub product locations should be included (if the given product is a parent product and in addition to the ones of the given product)
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdLocationsGet(productId: number, includeSubProducts?: boolean, query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdLocationsGet(productId, includeSubProducts, query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks the given amount of the given product as opened
     * @param {number} productId A valid product id
     * @param {InlineObject7} inlineObject7 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdOpenPost(productId: number, inlineObject7: InlineObject7, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdOpenPost(productId, inlineObject7, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the price history of the given product
     * @param {number} productId A valid product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdPriceHistoryGet(productId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdPriceHistoryGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prints the grocycode label of the given product on the configured label printer
     * @param {number} productId A valid product id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdPrintlabelGet(productId: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdPrintlabelGet(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merges two products into one
     * @param {number} productIdToKeep A valid product id of the product to keep
     * @param {number} productIdToRemove A valid product id of the product to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep: number, productIdToRemove: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdToKeepMergeProductIdToRemovePost(productIdToKeep, productIdToRemove, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfers the given amount of the given product from one location to another (this is currently not supported for tare weight handling enabled products)
     * @param {number} productId A valid product id
     * @param {InlineObject5} inlineObject5 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockProductsProductIdTransferPost(productId: number, inlineObject5: InlineObject5, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockProductsProductIdTransferPost(productId, inlineObject5, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds expired products to the given shopping list
     * @param {InlineObject15} [inlineObject15] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistAddExpiredProductsPost(inlineObject15?: InlineObject15, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistAddExpiredProductsPost(inlineObject15, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds currently missing products (below defined min. stock amount) to the given shopping list
     * @param {InlineObject13} [inlineObject13] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistAddMissingProductsPost(inlineObject13?: InlineObject13, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistAddMissingProductsPost(inlineObject13, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds overdue products to the given shopping list
     * @param {InlineObject14} [inlineObject14] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistAddOverdueProductsPost(inlineObject14?: InlineObject14, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistAddOverdueProductsPost(inlineObject14, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the product is already on the shopping list, the given amount will increase the amount of the already existing item, otherwise a new item will be added
     * @summary Adds the given amount of the given product to the given shopping list
     * @param {InlineObject17} inlineObject17 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistAddProductPost(inlineObject17: InlineObject17, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistAddProductPost(inlineObject17, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes all items from the given shopping list
     * @param {InlineObject16} [inlineObject16] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistClearPost(inlineObject16?: InlineObject16, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistClearPost(inlineObject16, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If the resulting amount is <= 0, the item will be completely removed from the given list, otherwise the given amount will reduce the amount of the existing item
     * @summary Removes the given amount of the given product from the given shopping list, if it is on it
     * @param {InlineObject18} inlineObject18 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockShoppinglistRemoveProductPost(inlineObject18: InlineObject18, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockShoppinglistRemoveProductPost(inlineObject18, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all stock bookings of the given transaction id
     * @param {string} transactionId A valid stock transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockTransactionsTransactionIdGet(transactionId: string, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockTransactionsTransactionIdGet(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Undoes a transaction
     * @param {string} transactionId A valid stock transaction id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockTransactionsTransactionIdUndoPost(transactionId: string, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockTransactionsTransactionIdUndoPost(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all products which are due soon, overdue, expired or currently missing
     * @param {number} [dueSoonDays] The number of days in which products are considered to be due soon
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockApi
     */
    public stockVolatileGet(dueSoonDays?: number, options?: AxiosRequestConfig) {
        return StockApiFp(this.configuration).stockVolatileGet(dueSoonDays, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockByBarcodeApi - axios parameter creator
 * @export
 */
export const StockByBarcodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds the given amount of the by its barcode given product to stock
         * @param {string} barcode Barcode
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeAddPost: async (barcode: string, inlineObject8: InlineObject8, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeAddPost', 'barcode', barcode)
            // verify required parameter 'inlineObject8' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeAddPost', 'inlineObject8', inlineObject8)
            const localVarPath = `/stock/products/by-barcode/{barcode}/add`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject8, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes the given amount of the by its barcode given product from stock
         * @param {string} barcode Barcode
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeConsumePost: async (barcode: string, inlineObject9: InlineObject9, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeConsumePost', 'barcode', barcode)
            // verify required parameter 'inlineObject9' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeConsumePost', 'inlineObject9', inlineObject9)
            const localVarPath = `/stock/products/by-barcode/{barcode}/consume`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject9, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns details of the given product by its barcode
         * @param {string} barcode Barcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeGet: async (barcode: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeGet', 'barcode', barcode)
            const localVarPath = `/stock/products/by-barcode/{barcode}`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Inventories the by its barcode given product (adds/removes based on the given new amount)
         * @param {string} barcode Barcode
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeInventoryPost: async (barcode: string, inlineObject11: InlineObject11, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeInventoryPost', 'barcode', barcode)
            // verify required parameter 'inlineObject11' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeInventoryPost', 'inlineObject11', inlineObject11)
            const localVarPath = `/stock/products/by-barcode/{barcode}/inventory`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject11, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks the given amount of the by its barcode given product as opened
         * @param {string} barcode Barcode
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeOpenPost: async (barcode: string, inlineObject12: InlineObject12, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeOpenPost', 'barcode', barcode)
            // verify required parameter 'inlineObject12' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeOpenPost', 'inlineObject12', inlineObject12)
            const localVarPath = `/stock/products/by-barcode/{barcode}/open`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject12, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Transfers the given amount of the by its barcode given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {string} barcode Barcode
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeTransferPost: async (barcode: string, inlineObject10: InlineObject10, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'barcode' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeTransferPost', 'barcode', barcode)
            // verify required parameter 'inlineObject10' is not null or undefined
            assertParamExists('stockProductsByBarcodeBarcodeTransferPost', 'inlineObject10', inlineObject10)
            const localVarPath = `/stock/products/by-barcode/{barcode}/transfer`
                .replace(`{${"barcode"}}`, encodeURIComponent(String(barcode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject10, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockByBarcodeApi - functional programming interface
 * @export
 */
export const StockByBarcodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockByBarcodeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds the given amount of the by its barcode given product to stock
         * @param {string} barcode Barcode
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeAddPost(barcode: string, inlineObject8: InlineObject8, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeAddPost(barcode, inlineObject8, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Removes the given amount of the by its barcode given product from stock
         * @param {string} barcode Barcode
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeConsumePost(barcode: string, inlineObject9: InlineObject9, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeConsumePost(barcode, inlineObject9, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns details of the given product by its barcode
         * @param {string} barcode Barcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeGet(barcode: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeGet(barcode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Inventories the by its barcode given product (adds/removes based on the given new amount)
         * @param {string} barcode Barcode
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeInventoryPost(barcode: string, inlineObject11: InlineObject11, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeInventoryPost(barcode, inlineObject11, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Marks the given amount of the by its barcode given product as opened
         * @param {string} barcode Barcode
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeOpenPost(barcode: string, inlineObject12: InlineObject12, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeOpenPost(barcode, inlineObject12, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Transfers the given amount of the by its barcode given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {string} barcode Barcode
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockProductsByBarcodeBarcodeTransferPost(barcode: string, inlineObject10: InlineObject10, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StockLogEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockProductsByBarcodeBarcodeTransferPost(barcode, inlineObject10, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockByBarcodeApi - factory interface
 * @export
 */
export const StockByBarcodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockByBarcodeApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds the given amount of the by its barcode given product to stock
         * @param {string} barcode Barcode
         * @param {InlineObject8} inlineObject8 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeAddPost(barcode: string, inlineObject8: InlineObject8, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsByBarcodeBarcodeAddPost(barcode, inlineObject8, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes the given amount of the by its barcode given product from stock
         * @param {string} barcode Barcode
         * @param {InlineObject9} inlineObject9 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeConsumePost(barcode: string, inlineObject9: InlineObject9, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsByBarcodeBarcodeConsumePost(barcode, inlineObject9, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns details of the given product by its barcode
         * @param {string} barcode Barcode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeGet(barcode: string, options?: any): AxiosPromise<ProductDetailsResponse> {
            return localVarFp.stockProductsByBarcodeBarcodeGet(barcode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Inventories the by its barcode given product (adds/removes based on the given new amount)
         * @param {string} barcode Barcode
         * @param {InlineObject11} inlineObject11 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeInventoryPost(barcode: string, inlineObject11: InlineObject11, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsByBarcodeBarcodeInventoryPost(barcode, inlineObject11, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks the given amount of the by its barcode given product as opened
         * @param {string} barcode Barcode
         * @param {InlineObject12} inlineObject12 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeOpenPost(barcode: string, inlineObject12: InlineObject12, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsByBarcodeBarcodeOpenPost(barcode, inlineObject12, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Transfers the given amount of the by its barcode given product from one location to another (this is currently not supported for tare weight handling enabled products)
         * @param {string} barcode Barcode
         * @param {InlineObject10} inlineObject10 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockProductsByBarcodeBarcodeTransferPost(barcode: string, inlineObject10: InlineObject10, options?: any): AxiosPromise<Array<StockLogEntry>> {
            return localVarFp.stockProductsByBarcodeBarcodeTransferPost(barcode, inlineObject10, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockByBarcodeApi - object-oriented interface
 * @export
 * @class StockByBarcodeApi
 * @extends {BaseAPI}
 */
export class StockByBarcodeApi extends BaseAPI {
    /**
     * 
     * @summary Adds the given amount of the by its barcode given product to stock
     * @param {string} barcode Barcode
     * @param {InlineObject8} inlineObject8 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeAddPost(barcode: string, inlineObject8: InlineObject8, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeAddPost(barcode, inlineObject8, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes the given amount of the by its barcode given product from stock
     * @param {string} barcode Barcode
     * @param {InlineObject9} inlineObject9 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeConsumePost(barcode: string, inlineObject9: InlineObject9, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeConsumePost(barcode, inlineObject9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns details of the given product by its barcode
     * @param {string} barcode Barcode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeGet(barcode: string, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeGet(barcode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Inventories the by its barcode given product (adds/removes based on the given new amount)
     * @param {string} barcode Barcode
     * @param {InlineObject11} inlineObject11 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeInventoryPost(barcode: string, inlineObject11: InlineObject11, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeInventoryPost(barcode, inlineObject11, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks the given amount of the by its barcode given product as opened
     * @param {string} barcode Barcode
     * @param {InlineObject12} inlineObject12 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeOpenPost(barcode: string, inlineObject12: InlineObject12, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeOpenPost(barcode, inlineObject12, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Transfers the given amount of the by its barcode given product from one location to another (this is currently not supported for tare weight handling enabled products)
     * @param {string} barcode Barcode
     * @param {InlineObject10} inlineObject10 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockByBarcodeApi
     */
    public stockProductsByBarcodeBarcodeTransferPost(barcode: string, inlineObject10: InlineObject10, options?: AxiosRequestConfig) {
        return StockByBarcodeApiFp(this.configuration).stockProductsByBarcodeBarcodeTransferPost(barcode, inlineObject10, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all config settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemConfigGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the time when the database was last changed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDbChangedTimeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/db-changed-time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns information about the installed grocy version, PHP runtime and OS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all localization strings (in the by the user desired language)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLocalizationStringsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/localization-strings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only when MODE == \'dev\', so should only be called then
         * @summary Logs a missing localization string
         * @param {MissingLocalizationRequest} missingLocalizationRequest A valid MissingLocalizationRequest object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLogMissingLocalizationPost: async (missingLocalizationRequest: MissingLocalizationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'missingLocalizationRequest' is not null or undefined
            assertParamExists('systemLogMissingLocalizationPost', 'missingLocalizationRequest', missingLocalizationRequest)
            const localVarPath = `/system/log-missing-localization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(missingLocalizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the current server time
         * @param {number} [offset] Offset of timestamp in seconds. Can be positive or negative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemTimeGet: async (offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all config settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemConfigGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemConfigGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the time when the database was last changed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemDbChangedTimeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DbChangedTimeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemDbChangedTimeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns information about the installed grocy version, PHP runtime and OS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all localization strings (in the by the user desired language)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemLocalizationStringsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemLocalizationStringsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Only when MODE == \'dev\', so should only be called then
         * @summary Logs a missing localization string
         * @param {MissingLocalizationRequest} missingLocalizationRequest A valid MissingLocalizationRequest object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemLogMissingLocalizationPost(missingLocalizationRequest: MissingLocalizationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemLogMissingLocalizationPost(missingLocalizationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the current server time
         * @param {number} [offset] Offset of timestamp in seconds. Can be positive or negative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemTimeGet(offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemTimeGet(offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all config settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemConfigGet(options?: any): AxiosPromise<object> {
            return localVarFp.systemConfigGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the time when the database was last changed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDbChangedTimeGet(options?: any): AxiosPromise<DbChangedTimeResponse> {
            return localVarFp.systemDbChangedTimeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns information about the installed grocy version, PHP runtime and OS
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoGet(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.systemInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all localization strings (in the by the user desired language)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLocalizationStringsGet(options?: any): AxiosPromise<object> {
            return localVarFp.systemLocalizationStringsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Only when MODE == \'dev\', so should only be called then
         * @summary Logs a missing localization string
         * @param {MissingLocalizationRequest} missingLocalizationRequest A valid MissingLocalizationRequest object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemLogMissingLocalizationPost(missingLocalizationRequest: MissingLocalizationRequest, options?: any): AxiosPromise<void> {
            return localVarFp.systemLogMissingLocalizationPost(missingLocalizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the current server time
         * @param {number} [offset] Offset of timestamp in seconds. Can be positive or negative.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemTimeGet(offset?: number, options?: any): AxiosPromise<TimeResponse> {
            return localVarFp.systemTimeGet(offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Returns all config settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemConfigGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemConfigGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the time when the database was last changed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemDbChangedTimeGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemDbChangedTimeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns information about the installed grocy version, PHP runtime and OS
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemInfoGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all localization strings (in the by the user desired language)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemLocalizationStringsGet(options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemLocalizationStringsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only when MODE == \'dev\', so should only be called then
     * @summary Logs a missing localization string
     * @param {MissingLocalizationRequest} missingLocalizationRequest A valid MissingLocalizationRequest object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemLogMissingLocalizationPost(missingLocalizationRequest: MissingLocalizationRequest, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemLogMissingLocalizationPost(missingLocalizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the current server time
     * @param {number} [offset] Offset of timestamp in seconds. Can be positive or negative.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemTimeGet(offset?: number, options?: AxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemTimeGet(offset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all tasks which are not done yet
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet: async (query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks the given task as completed
         * @param {number} taskId A valid task id
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIdCompletePost: async (taskId: number, inlineObject23: InlineObject23, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('tasksTaskIdCompletePost', 'taskId', taskId)
            // verify required parameter 'inlineObject23' is not null or undefined
            assertParamExists('tasksTaskIdCompletePost', 'inlineObject23', inlineObject23)
            const localVarPath = `/tasks/{taskId}/complete`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject23, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Marks the given task as not completed
         * @param {number} taskId A valid task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIdUndoPost: async (taskId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('tasksTaskIdUndoPost', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/undo`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all tasks which are not done yet
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CurrentTaskResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksGet(query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Marks the given task as completed
         * @param {number} taskId A valid task id
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksTaskIdCompletePost(taskId: number, inlineObject23: InlineObject23, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksTaskIdCompletePost(taskId, inlineObject23, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Marks the given task as not completed
         * @param {number} taskId A valid task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tasksTaskIdUndoPost(taskId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tasksTaskIdUndoPost(taskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all tasks which are not done yet
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<CurrentTaskResponse>> {
            return localVarFp.tasksGet(query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks the given task as completed
         * @param {number} taskId A valid task id
         * @param {InlineObject23} inlineObject23 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIdCompletePost(taskId: number, inlineObject23: InlineObject23, options?: any): AxiosPromise<void> {
            return localVarFp.tasksTaskIdCompletePost(taskId, inlineObject23, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Marks the given task as not completed
         * @param {number} taskId A valid task id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tasksTaskIdUndoPost(taskId: number, options?: any): AxiosPromise<void> {
            return localVarFp.tasksTaskIdUndoPost(taskId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * 
     * @summary Returns all tasks which are not done yet
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksGet(query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks the given task as completed
     * @param {number} taskId A valid task id
     * @param {InlineObject23} inlineObject23 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIdCompletePost(taskId: number, inlineObject23: InlineObject23, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksTaskIdCompletePost(taskId, inlineObject23, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Marks the given task as not completed
     * @param {number} taskId A valid task id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public tasksTaskIdUndoPost(taskId: number, options?: AxiosRequestConfig) {
        return TasksApiFp(this.configuration).tasksTaskIdUndoPost(taskId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all users
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (query?: Array<string>, order?: string, limit?: number, offset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)

            if (query) {
                localVarQueryParameter['query[]'] = query;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new user
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersPost', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdDelete', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsGet: async (userId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPermissionsGet', 'userId', userId)
            const localVarPath = `/users/{userId}/permissions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a permission to the given user
         * @param {number} userId A valid user id
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsPost: async (userId: number, inlineObject1: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPermissionsPost', 'userId', userId)
            // verify required parameter 'inlineObject1' is not null or undefined
            assertParamExists('usersUserIdPermissionsPost', 'inlineObject1', inlineObject1)
            const localVarPath = `/users/{userId}/permissions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replaces the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsPut: async (userId: number, inlineObject: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPermissionsPut', 'userId', userId)
            // verify required parameter 'inlineObject' is not null or undefined
            assertParamExists('usersUserIdPermissionsPut', 'inlineObject', inlineObject)
            const localVarPath = `/users/{userId}/permissions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edits the given user
         * @param {number} userId A valid user id
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut: async (userId: number, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPut', 'userId', userId)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('usersUserIdPut', 'user', user)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "GROCY-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns all users
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(query, order, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a new user
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdDelete(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdDelete(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPermissionsGet(userId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineResponse2002>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPermissionsGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a permission to the given user
         * @param {number} userId A valid user id
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPermissionsPost(userId: number, inlineObject1: InlineObject1, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPermissionsPost(userId, inlineObject1, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replaces the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPermissionsPut(userId: number, inlineObject: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPermissionsPut(userId, inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edits the given user
         * @param {number} userId A valid user id
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPut(userId: number, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPut(userId, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns all users
         * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
         * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
         * @param {number} [limit] The maximum number of objects to return
         * @param {number} [offset] The number of objects to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: any): AxiosPromise<Array<UserDto>> {
            return localVarFp.usersGet(query, order, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new user
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.usersPost(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsGet(userId: number, options?: any): AxiosPromise<Array<InlineResponse2002>> {
            return localVarFp.usersUserIdPermissionsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a permission to the given user
         * @param {number} userId A valid user id
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsPost(userId: number, inlineObject1: InlineObject1, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdPermissionsPost(userId, inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replaces the assigned permissions of the given user
         * @param {number} userId A valid user id
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPermissionsPut(userId: number, inlineObject: InlineObject, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdPermissionsPut(userId, inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edits the given user
         * @param {number} userId A valid user id
         * @param {User} user A valid user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPut(userId: number, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdPut(userId, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI {
    /**
     * 
     * @summary Returns all users
     * @param {Array<string>} [query] An array of filter conditions, each of them is a string in the form of &#x60;&lt;field&gt;&lt;condition&gt;&lt;value&gt;&#x60; where&lt;br&gt;&#x60;&lt;field&gt;&#x60; is a valid field name&lt;br&gt;&#x60;&lt;condition&gt;&#x60; is a comparison operator, one of&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&#x3D;&#x60; equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!&#x3D;&#x60; not equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;~&#x60; LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;!~&#x60; not LIKE&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x60; less&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x60; greater&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&lt;&#x3D;&#x60; less or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;&gt;&#x3D;&#x60; greater or equal&lt;br&gt;&amp;nbsp;&amp;nbsp;&#x60;§&#x60; regular expression&lt;br&gt;&#x60;&lt;value&gt;&#x60; is the value to search for
     * @param {string} [order] A valid field name by which the response should be ordered, use the separator &#x60;:&#x60; to specify the sort order (&#x60;asc&#x60; or &#x60;desc&#x60;, defaults to &#x60;asc&#x60; when omitted)
     * @param {number} [limit] The maximum number of objects to return
     * @param {number} [offset] The number of objects to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersGet(query?: Array<string>, order?: string, limit?: number, offset?: number, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersGet(query, order, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new user
     * @param {User} user A valid user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersPost(user: User, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersPost(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes the given user
     * @param {number} userId A valid user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersUserIdDelete(userId: number, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the assigned permissions of the given user
     * @param {number} userId A valid user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersUserIdPermissionsGet(userId: number, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersUserIdPermissionsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a permission to the given user
     * @param {number} userId A valid user id
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersUserIdPermissionsPost(userId: number, inlineObject1: InlineObject1, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersUserIdPermissionsPost(userId, inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replaces the assigned permissions of the given user
     * @param {number} userId A valid user id
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersUserIdPermissionsPut(userId: number, inlineObject: InlineObject, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersUserIdPermissionsPut(userId, inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edits the given user
     * @param {number} userId A valid user id
     * @param {User} user A valid user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public usersUserIdPut(userId: number, user: User, options?: AxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).usersUserIdPut(userId, user, options).then((request) => request(this.axios, this.basePath));
    }
}


